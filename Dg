_ENV = (getgenv or getrenv or getfenv)()

if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- =====================================================
-- SERVICES
-- =====================================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local VIM = game:GetService("VirtualInputManager")
local Player = Players.LocalPlayer

-- =====================================================
-- SISTEMA DE SALVAMENTO JSON
-- =====================================================
local SETTINGS_FILE = "AllanHub_Settings.json"
local DUNGEON_RUNES_FILE = "AllanHub_DungeonRunes.json"

local Settings = {
    -- Dungeon
    AutoFarm = false,
    AutoBuyTicket = false,
    MoveMode = "Tween",
    UseRunesAuto = false,
    AutoRebirth = false,
    
    -- Runas
    RuneSlot1 = "Nenhuma",
    RuneSlot2 = "Nenhuma",
    RuneSlot3 = "Nenhuma",
    RuneSlot4 = "Nenhuma",
    RuneSlot5 = "Nenhuma",
    
    -- Castle
    CastleInf = false,
    AutoCastle = false,
    CastleCreateOnly = false,
    CastleSpeed = "1",
    CastleSpeedEnabled = false,
    EntryFloor = 1,
    ResetFloor = 100
}

local function SaveSettings()
    if not writefile then 
        warn("Executor não suporta writefile!")
        return 
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(Settings)
        writefile(SETTINGS_FILE, encoded)
        print("Configurações salvas!")
    end)
    
    if not success then
        warn("Erro ao salvar:", err)
    end
end

local function LoadSettings()
    if not readfile or not isfile then
        warn("Executor não suporta readfile!")
        return
    end
    
    if not isfile(SETTINGS_FILE) then
        print("Criando arquivo de configuração...")
        SaveSettings()
        return
    end
    
    local success, err = pcall(function()
        local data = readfile(SETTINGS_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        for key, value in pairs(decoded) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        
        print("Configurações carregadas!")
    end)
    
    if not success then
        warn("Erro ao carregar:", err)
    end
end

LoadSettings()

-- =====================================================
-- SISTEMA DE RUNAS DA DUNGEON (PERSISTENTE)
-- =====================================================
local function SaveDungeonRunes()
    if not writefile then return end
    
    local activerunes = {}
    for slot = 1, 5 do
        local runeName = Settings["RuneSlot" .. slot]
        if runeName and runeName ~= "Nenhuma" then
            activerunes["Slot" .. slot] = runeName
        end
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(activerunes)
        writefile(DUNGEON_RUNES_FILE, encoded)
        print("Runas da dungeon salvas no arquivo persistente!")
    end)
    
    if not success then
        warn("Erro ao salvar runas da dungeon:", err)
    end
end

local function LoadDungeonRunes()
    if not readfile or not isfile then return false end
    
    if not isfile(DUNGEON_RUNES_FILE) then
        print("Nenhum arquivo de runas da dungeon encontrado")
        return false
    end
    
    local success, err = pcall(function()
        local data = readfile(DUNGEON_RUNES_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        print("Carregando runas salvas da dungeon...")
        
        for slotKey, runeName in pairs(decoded) do
            local slotNum = tonumber(string.match(slotKey, "Slot(%d+)"))
            if slotNum then
                Settings["RuneSlot" .. slotNum] = runeName
                print("  Slot " .. slotNum .. ": " .. runeName)
            end
        end
        
        print("Runas da dungeon carregadas com sucesso!")
    end)
    
    if not success then
        warn("Erro ao carregar runas da dungeon:", err)
        return false
    end
    
    return true
end

local function ClearDungeonRunes()
    if not delfile or not isfile then return end
    
    if isfile(DUNGEON_RUNES_FILE) then
        delfile(DUNGEON_RUNES_FILE)
        print("Arquivo de runas da dungeon limpo!")
    end
end

-- CARREGAR RUNAS DA DUNGEON SE EXISTIR (PRIORIDADE MÁXIMA)
if LoadDungeonRunes() then
    print("Runas da dungeon restauradas do arquivo persistente!")
end

-- =====================================================
-- CONFIG (USA SETTINGS)
-- =====================================================
Config = Settings

-- =====================================================
-- NOTIFICATION
-- =====================================================
local lastNotificationTime = 0
local notificationCooldown = 10
local currentTime = tick()

if currentTime - lastNotificationTime >= notificationCooldown then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Allan Hub",
        Text = "Carregando...",
        Duration = 5
    })
    lastNotificationTime = currentTime
end

-- =====================================================
-- BRIDGENET2
-- =====================================================
local BridgeNet2 = require(ReplicatedStorage:WaitForChild("BridgeNet2"))
local DungeonBridge = BridgeNet2.ReferenceBridge("GENERAL_EVENT")

-- FUNÇÃO PARA PEGAR O ID DA DUNGEON ATIVA DO PLAYER
local function GetPlayerDungeonId()
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if not infos then return nil end
    
    local dungeons = infos:FindFirstChild("__Dungeons")
    if not dungeons then return nil end
    
    -- Procurar dungeon onde o player é o líder
    for _, dungeon in ipairs(dungeons:GetChildren()) do
        local leader = dungeon:GetAttribute("Leader")
        if leader == Player.UserId then
            return leader -- O ID da dungeon é o UserId do líder
        end
    end
    
    return nil
end

local function SafeFire(payload)
    if not DungeonBridge then return end
    
    -- SE FOR AÇÃO DE DUNGEON, ADICIONAR O ID DA DUNGEON AUTOMATICAMENTE
    if payload.Event == "DungeonAction" and payload.Action ~= "Create" and payload.Action ~= "BuyTicket" then
        local dungeonId = GetPlayerDungeonId()
        if dungeonId then
            payload.Dungeon = dungeonId
        end
    end
    
    local ok, err = pcall(function()
        DungeonBridge:Fire(payload)
    end)
    if not ok then
        warn("SafeFire error:", err, payload)
    end
end

-- =====================================================
-- NOVA UI (GITHUB)
-- =====================================================
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/allanxsix/Teste/refs/heads/main/uiallanhub"))()

local Main = Library.CreateMain({
    Desc = " _ng.shinichi"
})

-- =====================================================
-- PAGES
-- =====================================================
local PageDungeon = Main.CreatePage({
    Page_Name = "Dungeon",
    Page_Title = "Dungeon System"
})

local PageCastle = Main.CreatePage({
    Page_Name = "Castle",
    Page_Title = "Castelo Infernal"
})

local PageIslands = Main.CreatePage({
    Page_Name = "Islands",
    Page_Title = "Islands"
})

local PageSettings = Main.CreatePage({
    Page_Name = "Settings",
    Page_Title = "Settings"
})

-- =====================================================
-- SECTIONS
-- =====================================================
local SectionDungeonMain = PageDungeon.CreateSection("Main Settings")
local SectionDungeonRunes = PageDungeon.CreateSection("Sistema de Runas")
local SectionCastleMain = PageCastle.CreateSection("Castle Settings")
local SectionIslandsMain = PageIslands.CreateSection("Islands")

local function UpdateStatus(text)
    -- Removido para deixar o script mais limpo
end

-- =====================================================
-- FLAGS / STATES
-- =====================================================
local CreatingDungeon = false
local DungeonRunning = false
local StartingDungeon = false
local Rebirthing = false
local SpawnConfirmTime = 0
local currentTween = nil

-- =====================================================
-- RUNAS (5 SLOTS)
-- =====================================================
local MAX_RUNE_SLOTS = 5
local RuneSlots = {}
for i = 1, MAX_RUNE_SLOTS do RuneSlots[i] = "" end

local ItemsInfo
pcall(function()
    ItemsInfo = require(ReplicatedStorage:WaitForChild("Indexer"):WaitForChild("ItemsInfo"))
end)

local AvailableRunes = {}

local function ScanRunes()
    table.clear(AvailableRunes)
    if not ItemsInfo then 
        warn("ItemsInfo não encontrado!")
        return 
    end

    print("Escaneando runas...")
    local count = 0

    for id, data in pairs(ItemsInfo) do
        if typeof(data) == "table" then
            local t = tostring(data.Type or "")
            local n = tostring(data.Name or "")
            
            if string.find(string.lower(t), "rune") or string.find(string.lower(n), "rune") then
                table.insert(AvailableRunes, {
                    Id = id,
                    Name = data.Name or tostring(id)
                })
                count = count + 1
            end
        end
    end

    print("Total de runas:", count)
    
    if count == 0 then
        warn("Nenhuma runa detectada!")
    end
end

ScanRunes()

local RuneNames = { "Nenhuma" }
for _, r in ipairs(AvailableRunes) do
    table.insert(RuneNames, r.Name)
end

-- RESTAURAR RUNAS SALVAS DOS SETTINGS
local function RestoreSavedRunes()
    local restoredCount = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local savedRuneName = Settings["RuneSlot" .. slot]
        
        if savedRuneName and savedRuneName ~= "Nenhuma" then
            -- Procurar o ID da runa pelo nome salvo
            for _, rune in ipairs(AvailableRunes) do
                if rune.Name == savedRuneName then
                    RuneSlots[slot] = rune.Id
                    restoredCount = restoredCount + 1
                    print("Runa Slot " .. slot .. " restaurada: " .. savedRuneName .. " (ID: " .. rune.Id .. ")")
                    break
                end
            end
        end
    end
    
    if restoredCount > 0 then
        print("Total de " .. restoredCount .. " runas restauradas das configurações salvas!")
    end
    
    return restoredCount
end

-- RESTAURAR AS RUNAS APÓS ESCANEAR (agora usa as runas do arquivo persistente)
RestoreSavedRunes()

-- =====================================================
-- UI DUNGEON
-- =====================================================
SectionDungeonMain.CreateToggle({
    Title = "Auto Farm Dungeon",
    Default = Settings.AutoFarm
}, function(v)
    Settings.AutoFarm = v
    SaveSettings()
end)

SectionDungeonMain.CreateToggle({
    Title = "Auto Buy Ticket",
    Default = Settings.AutoBuyTicket
}, function(v)
    Settings.AutoBuyTicket = v
    SaveSettings()
end)

SectionDungeonMain.CreateDropdown({
    Title = "Movement Mode",
    List = { "Tween", "Teleport" },
    Default = Settings.MoveMode
}, function(v)
    Settings.MoveMode = v
    SaveSettings()
end)

SectionDungeonMain.CreateToggle({
    Title = "Auto Rebirth (MAX)",
    Desc = "Faz rebirth automaticamente ao atingir level máximo",
    Default = Settings.AutoRebirth
}, function(v)
    Settings.AutoRebirth = v
    SaveSettings()
end)

-- =====================================================
-- UI RUNAS
-- =====================================================
for slot = 1, MAX_RUNE_SLOTS do
    SectionDungeonRunes.CreateDropdown({
        Title = "Runa Slot " .. slot,
        List = RuneNames,
        Default = Settings["RuneSlot" .. slot]
    }, function(v)
        Settings["RuneSlot" .. slot] = v
        
        if v == "Nenhuma" then
            RuneSlots[slot] = ""
        else
            for _, r in ipairs(AvailableRunes) do
                if r.Name == v then
                    RuneSlots[slot] = r.Id
                    print("Slot " .. slot .. " configurado: " .. v .. " (ID: " .. r.Id .. ")")
                    break
                end
            end
        end
        
        SaveSettings()
        
        -- SALVAR NO ARQUIVO PERSISTENTE DE RUNAS DA DUNGEON
        if Settings.UseRunesAuto then
            SaveDungeonRunes()
        end
    end)
end

SectionDungeonRunes.CreateToggle({
    Title = "Usar Runas Automaticamente",
    Desc = "Aplica as runas sempre que criar uma dungeon",
    Default = Settings.UseRunesAuto
}, function(v)
    Settings.UseRunesAuto = v
    SaveSettings()
    
    if v then
        -- SALVAR RUNAS NO ARQUIVO PERSISTENTE AO ATIVAR
        SaveDungeonRunes()
        
        local count = 0
        for i = 1, MAX_RUNE_SLOTS do
            if RuneSlots[i] ~= "" then count = count + 1 end
        end
        Library.CreateNoti({
            Title = "Runas Automáticas",
            Desc = "Ativado! " .. count .. " runas serão aplicadas",
            ShowTime = 4
        })
    else
        -- LIMPAR ARQUIVO PERSISTENTE AO DESATIVAR
        ClearDungeonRunes()
        Library.CreateNoti({
            Title = "Runas Automáticas",
            Desc = "Desativado! Arquivo de runas limpo.",
            ShowTime = 4
        })
    end
end)

-- =====================================================
-- DUNGEON FUNCTIONS
-- =====================================================
local EnemiesFolder = workspace.__Main.__Enemies.Server

local function GetClosestEnemy()
    local char = Player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    local best, dist = nil, math.huge

    for _, e in ipairs(EnemiesFolder:GetChildren()) do
        local hp = e:GetAttribute("HP")
        if hp and hp > 0 and e.Position then
            local d = (pos - e.Position).Magnitude
            if d < dist then
                dist = d
                best = e
            end
        end
    end

    return best
end

local function MoveToEnemy(enemy)
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if Settings.MoveMode == "Teleport" then
        if currentTween then currentTween:Cancel() end
        root.CFrame = enemy.CFrame
    else
        if currentTween then currentTween:Cancel() end
        currentTween = TweenService:Create(
            root,
            TweenInfo.new(0.3),
            { CFrame = enemy.CFrame }
        )
        currentTween:Play()
    end
end

local function AttackEnemy(enemy)
    SafeFire({
        PetPos = {},
        AttackType = "All",
        Event = "Attack",
        Enemy = enemy.Name
    })
end

local function BuyDungeonTicket()
    SafeFire({
        Event = "DungeonAction",
        Action = "BuyTicket"
    })
end

-- NOVA FUNÇÃO APPLY RUNES COM DETECÇÃO DE ID
local function ApplyRunes()
    if not Settings.UseRunesAuto then 
        return 0 
    end
    
    -- PEGAR ID DA DUNGEON
    local dungeonId = GetPlayerDungeonId()
    if not dungeonId then
        print("ID da dungeon não encontrado - não é possível adicionar runas")
        return 0
    end
    
    print("ID da Dungeon detectado:", dungeonId)
    
    local runesApplied = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local runeId = RuneSlots[slot]
        if runeId ~= "" then
            -- USAR MÉTODO QUE FUNCIONA: AddItems com ID da Dungeon
            SafeFire({
                Dungeon = dungeonId,
                Event = "DungeonAction",
                Action = "AddItems",
                Slot = slot,
                Item = runeId
            })
            runesApplied = runesApplied + 1
            print("Aplicando Runa Slot " .. slot .. ": " .. runeId)
            task.wait(0.4)
        end
    end
    
    return runesApplied
end

local function CreateDungeon()
    if CreatingDungeon or Rebirthing then return end

    CreatingDungeon = true
    StartingDungeon = true
    UpdateStatus("Preparing Dungeon...")

    -- SALVAR RUNAS ANTES DE CRIAR A DUNGEON (caso o jogo recarregue)
    if Settings.UseRunesAuto then
        SaveDungeonRunes()
        print("Runas salvas antes de criar a dungeon")
    end

    -- Comprar ticket
    if Settings.AutoBuyTicket then
        BuyDungeonTicket()
        task.wait(0.8)
    end

    -- Criar dungeon PRIMEIRO
    UpdateStatus("Creating Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Create"
    })
    
    task.wait(1.5)

    -- Aplicar runas DEPOIS de criar (com ID detectado)
    if Settings.UseRunesAuto then
        UpdateStatus("Applying Runes...")
        local runesApplied = ApplyRunes()
        
        if runesApplied > 0 then
            UpdateStatus(runesApplied .. " Runas Ready!")
            task.wait(0.5)
        end
    end

    -- Iniciar dungeon
    UpdateStatus("Starting Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Start"
    })

    task.delay(2, function()
        CreatingDungeon = false
    end)
end

-- =====================================================
-- AUTO DUNGEON LOOP
-- =====================================================
RunService.Heartbeat:Connect(function(dt)
    if not Settings.AutoFarm or Rebirthing then
        DungeonRunning = false
        SpawnConfirmTime = 0
        UpdateStatus("Idle")
        return
    end

    local enemy = GetClosestEnemy()

    if enemy then
        DungeonRunning = true
        StartingDungeon = false
        SpawnConfirmTime = 0
        UpdateStatus("Farming (" .. Settings.MoveMode .. ")")
        MoveToEnemy(enemy)
        AttackEnemy(enemy)
        return
    end

    if DungeonRunning then
        SpawnConfirmTime += dt
        UpdateStatus(("Finalizando Dungeon %.1fs"):format(SpawnConfirmTime))
        if SpawnConfirmTime >= 1.8 then
            DungeonRunning = false
            SpawnConfirmTime = 0
            CreateDungeon()
        end
    else
        CreateDungeon()
    end
end)

-- =====================================================
-- LEVEL CHECK (VERIFICAÇÃO DE LEVEL MÁXIMO)
-- =====================================================
local PlayerGui = Player:WaitForChild("PlayerGui")
local ExpText = PlayerGui
    :WaitForChild("Hud")
    :WaitForChild("BottomContainer")
    :WaitForChild("ExpBar")
    :WaitForChild("ExpText")

local function GetLevelInfo()
    local text = ExpText.Text
    if not text then return nil, false end
    local level = tonumber(string.match(text, "Level:%s*(%d+)"))
    
    -- Verifica se o texto contém "MAX" ou "MÁXIMO"
    if string.find(text, "MAX") or string.find(text, "MÁXIMO") then
        return level, true
    end
    
    -- Verifica se a experiência necessária é 0 (level máximo)
    local cur, need = string.match(text, "%((%d+)%/(%d+)%)")
    if cur and need and tonumber(need) == 0 then
        return level, true
    end
    
    return level, false
end

-- =====================================================
-- AUTO REBIRTH
-- =====================================================
local rebirthCooldown = 0

-- Loop de Stats (PlayerExp a cada 30s)
task.spawn(function()
    while true do
        if Settings.AutoRebirth then
            SafeFire({
                Event = "StatsUp",
                Stats = "PlayerExp",
                Points = 2000
            })
        end
        task.wait(30)
    end
end)

-- Loop de Stats (ShadowRange a cada 40s)
task.spawn(function()
    while true do
        if Settings.AutoRebirth then
            SafeFire({
                Event = "StatsUp",
                Stats = "ShadowRange",
                Points = 400
            })
        end
        task.wait(40)
    end
end)

RunService.Heartbeat:Connect(function(dt)
    rebirthCooldown += dt

    if not Settings.AutoRebirth or rebirthCooldown < 10 then return end
    if Rebirthing or CreatingDungeon then return end

    local lvl, isMax = GetLevelInfo()
    
    -- Só faz rebirth se estiver no level máximo
    if isMax then
        print("LEVEL MAX! Fazendo Rebirth...")
        Rebirthing = true
        
        SafeFire({
            Event = "Rebirth"
        })
        
        task.wait(2)
        Rebirthing = false
        rebirthCooldown = 0
    end
end)

-- =====================================================
-- CASTLE VARIABLES
-- =====================================================
local castleInfEnabled = false
local autoCastleEnabled = false
local castleCreateOnlyEnabled = false
local entryFloor = Settings.EntryFloor
local resetFloor = Settings.ResetFloor
local selectedCastleSpeed = Settings.CastleSpeed

-- AUTO F2 + F3
local autoF2F3Enabled = false
local f2f3Mode = "8x"
local F2F3_INTERVALS = {
    ["1x"] = 60,    -- 1 minuto normal
    ["4x"] = 15,    -- 1 minuto acelerado 4x (60/4)
    ["8x"] = 7.5    -- 1 minuto acelerado 8x (60/8)
}
local DELAY_F2_F3 = 1.5
local castleSpeedEnabled = Settings.CastleSpeedEnabled

-- =====================================================
-- CASTLE FUNCTIONS
-- =====================================================
local function pressKey(key)
    VIM:SendKeyEvent(true, key, false, game)
    task.wait(0.05)
    VIM:SendKeyEvent(false, key, false, game)
end

local function autoF2F3Loop()
    task.spawn(function()
        while autoF2F3Enabled do
            pressKey(Enum.KeyCode.F2)
            task.wait(DELAY_F2_F3)
            pressKey(Enum.KeyCode.F3)
            task.wait(F2F3_INTERVALS[f2f3Mode])
        end
    end)
end

local function getCurrentCastleFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    local current = nil
    for i = 1, 800 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end
    return current
end

local function buyCastleTicket()
    SafeFire({
        Event = "CastleAction",
        Action = "BuyTicket",
        Type = "Gems"
    })
end

local function createCastle()
    SafeFire({
        Event = "CastleAction",
        Action = "Create"
    })
    task.wait(2.5)
end

local function joinCastle(floor)
    SafeFire({
        Event = "CastleAction",
        Action = "Join",
        Floor = tostring(floor or entryFloor),
        Check = true
    })
end

local function findFirePortal()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    for i = 1, 300 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local portal = room:FindFirstChild("FirePortal", true)
            if portal then
                return portal, i
            end
        end
    end
    return nil
end

local function teleportToFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local char = Player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    hrp.CFrame = portal:GetPivot() * CFrame.new(0, 2, -3)
    hrp.Velocity = Vector3.zero
    return true
end

local function activateFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local prompt = portal:FindFirstChildWhichIsA("ProximityPrompt", true)
    if not prompt then return false end

    for _ = 1, 3 do
        pcall(function()
            fireproximityprompt(prompt)
        end)
        task.wait(0.15)
    end
    return true
end

local function farmCastleMobs()
    local mobsKilled = false
    local enemiesFolder = workspace:FindFirstChild("__Main")

    if enemiesFolder then
        enemiesFolder = enemiesFolder:FindFirstChild("__Enemies")
        if enemiesFolder then
            enemiesFolder = enemiesFolder:FindFirstChild("Server")
        end
    end

    if enemiesFolder then
        for _, mob in pairs(enemiesFolder:GetChildren()) do
            if not castleInfEnabled then break end

            local hp = mob:GetAttribute("HP")
            if hp and hp > 0 and mob.Position then
                local char = Player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                
                if hrp then
                    hrp.CFrame = mob.CFrame * CFrame.new(0, 0, 3)

                    SafeFire({
                        PetPos = {},
                        AttackType = "All",
                        Event = "Attack",
                        Enemy = mob.Name
                    })

                    while castleInfEnabled and mob.Parent do
                        local currentHP = mob:GetAttribute("HP")
                        if not currentHP or currentHP <= 0 then
                            break
                        end
                        task.wait(0.2)
                    end

                    mobsKilled = true
                end
            end
        end
    end

    return mobsKilled
end

-- =====================================================
-- CASTLE LOOPS
-- =====================================================
local function castleInfLoop()
    task.spawn(function()
        while castleInfEnabled do
            local hasMobs = farmCastleMobs()
            if not hasMobs then
                if teleportToFirePortal() then
                    task.wait(1)
                    activateFirePortal()
                end
            end
            task.wait(0.4)
        end
    end)
end

local function autoCastleLoop()
    task.spawn(function()
        while autoCastleEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            else
                if currentFloor >= resetFloor then
                    buyCastleTicket()
                    task.wait(1)
                    createCastle()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    farmCastleMobs()
                end
            end
            task.wait(0.5)
        end
    end)
end

local function castleCreateOnlyLoop()
    task.spawn(function()
        while castleCreateOnlyEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            end
            task.wait(1)
        end
    end)
end

-- =====================================================
-- CASTLE UI
-- =====================================================
SectionCastleMain.CreateBox({
    Title = "Andar de Entrada",
    Placeholder = "Digite o andar",
    Default = tostring(Settings.EntryFloor),
    Number = true
}, function(v)
    local n = tonumber(v)
    if n then
        entryFloor = n
        Settings.EntryFloor = n
        SaveSettings()
    end
end)

SectionCastleMain.CreateBox({
    Title = "Andar de Reset",
    Placeholder = "Digite o andar",
    Default = tostring(Settings.ResetFloor),
    Number = true
}, function(v)
    local n = tonumber(v)
    if n then
        resetFloor = n
        Settings.ResetFloor = n
        SaveSettings()
    end
end)

SectionCastleMain.CreateToggle({
    Title = "Castle INF (Farm + Portal)",
    Default = Settings.CastleInf
}, function(v)
    castleInfEnabled = v
    Settings.CastleInf = v
    SaveSettings()
    if v then castleInfLoop() end
end)

SectionCastleMain.CreateToggle({
    Title = "Auto Castle (Create + Reset)",
    Default = Settings.AutoCastle
}, function(v)
    autoCastleEnabled = v
    Settings.AutoCastle = v
    SaveSettings()
    if v then autoCastleLoop() end
end)

SectionCastleMain.CreateToggle({
    Title = "Auto Castle (Criar Apenas)",
    Default = Settings.CastleCreateOnly
}, function(v)
    castleCreateOnlyEnabled = v
    Settings.CastleCreateOnly = v
    SaveSettings()
    if v then castleCreateOnlyLoop() end
end)

SectionCastleMain.CreateDropdown({
    Title = "Speed do Castelo",
    List = {"1", "2", "4"},
    Default = Settings.CastleSpeed
}, function(v)
    selectedCastleSpeed = v
    Settings.CastleSpeed = v
    SaveSettings()
    
    if castleSpeedEnabled then
        SafeFire({
            Event = "CastleAction",
            Action = "SpeedUp",
            Speed = tonumber(v)
        })
    end
end)

SectionCastleMain.CreateToggle({
    Title = "Ativar Speed do Castelo",
    Default = Settings.CastleSpeedEnabled
}, function(v)
    castleSpeedEnabled = v
    Settings.CastleSpeedEnabled = v
    SaveSettings()
    
    if v then
        SafeFire({
            Event = "CastleAction",
            Action = "SpeedUp",
            Speed = tonumber(selectedCastleSpeed)
        })
    end
end)

SectionCastleMain.CreateDropdown({
    Title = "Modo Auto F2 + F3",
    List = {"1x", "4x", "8x"},
    Default = "8x"
}, function(v)
    f2f3Mode = v
end)

SectionCastleMain.CreateToggle({
    Title = "Ativar Auto F2 + F3",
    Desc = "Pressiona F2 e F3 automaticamente"
}, function(v)
    autoF2F3Enabled = v
    if v then
        autoF2F3Loop()
        Library.CreateNoti({
            Title = "Auto F2+F3",
            Desc = "Ativado no modo " .. f2f3Mode,
            ShowTime = 3
        })
    end
end)

-- =====================================================
-- ISLANDS
-- =====================================================
local SelectedIslandName = nil
local IslandMap = {}
local function GetWorld()
local extra = workspace:FindFirstChild("__Extra")
if not extra then return nil end
return extra:FindFirstChild("__Spawns")
end
local function GetIslandDisplayName(island)
if island:GetAttribute("DisplayName") then return island:GetAttribute("DisplayName") end
if island:GetAttribute("Name") then return island:GetAttribute("Name") end
for _, child in ipairs(island:GetChildren()) do
if child:IsA("StringValue") then
return child.Value
end
end
return island.Name
end
local function ScanIslands()
table.clear(IslandMap)
local World = GetWorld()
if not World then return {} end
local list = {}
for _, island in ipairs(World:GetChildren()) do
local displayName = GetIslandDisplayName(island)
IslandMap[displayName] = island
table.insert(list, displayName)
end
table.sort(list)
return list
end
local function TeleportToIsland(islandModel)
local char = Players.LocalPlayer.Character
if not char or not char:FindFirstChild("HumanoidRootPart") then return end
local hrp = char.HumanoidRootPart
if islandModel.GetPivot then
hrp.CFrame = islandModel:GetPivot() * CFrame.new(0, 10, 0)
elseif islandModel.PrimaryPart then
hrp.CFrame = islandModel.PrimaryPart.CFrame * CFrame.new(0, 10, 0)
elseif islandModel:IsA("BasePart") then
hrp.CFrame = islandModel.CFrame * CFrame.new(0, 10, 0)
end
end
SectionIslandsMain.CreateDropdown({
    Title = "Ilhas Detectadas",
    List = ScanIslands()
}, function(value)
    SelectedIslandName = value
end)

SectionIslandsMain.CreateButton({
    Title = "Teleportar Ilha Selecionada"
}, function()
    if not SelectedIslandName then
        Library.CreateNoti({
            Title = "Erro",
            Desc = "Nenhuma ilha selecionada",
            ShowTime = 3
        })
        return
    end
    local islandModel = IslandMap[SelectedIslandName]
    if islandModel then
        TeleportToIsland(islandModel)
        Library.CreateNoti({
            Title = "Teleport",
            Desc = "Você foi para " .. SelectedIslandName,
            ShowTime = 3
        })
    end
end)

-- =====================================================
-- SETTINGS
-- =====================================================
local SectionSettings = PageSettings.CreateSection("Config")

SectionSettings.CreateLabel({
    Title = "Sistema de Salvamento\nSuas configurações são salvas automaticamente!"
})

SectionSettings.CreateButton({
    Title = "Salvar Configurações"
}, function()
    SaveSettings()
    Library.CreateNoti({
        Title = "Salvamento",
        Desc = "Configurações salvas com sucesso!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Recarregar Configurações"
}, function()
    LoadSettings()
    Library.CreateNoti({
        Title = "Salvamento",
        Desc = "Configurações recarregadas!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Resetar Todas Configurações"
}, function()
    if delfile and isfile(SETTINGS_FILE) then
        delfile(SETTINGS_FILE)
    end
    
    for key in pairs(Settings) do
        if key:find("RuneSlot") then
            Settings[key] = "Nenhuma"
        elseif type(Settings[key]) == "boolean" then
            Settings[key] = false
        elseif key == "MoveMode" then
            Settings[key] = "Tween"
        elseif key == "CastleSpeed" then
            Settings[key] = "1"
        elseif key == "EntryFloor" then
            Settings[key] = 1
        elseif key == "ResetFloor" then
            Settings[key] = 100
        end
    end
    
    SaveSettings()
    
    Library.CreateNoti({
        Title = "Resetado",
        Desc = "Configurações resetadas com sucesso!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Reconectar Servidor"
}, function()
    game:GetService("TeleportService"):Teleport(game.PlaceId, Player)
end)

-- =====================================================
-- NOTIFICAÇÃO FINAL
-- =====================================================
Library.CreateNoti({
    Title = "Allan Hub V2",
    Desc = "Script carregado com sucesso!\nSistema de salvamento ativo\nRunas detectadas: " .. #AvailableRunes,
    ShowTime = 6
})

print("ALLAN HUB V2 CARREGADO")
print("Sistema de salvamento: ATIVO")
print("Runas detectadas: " .. #AvailableRunes)
print("Detecção automática de ID da dungeon: ATIVO")
print("Todas as configurações serão salvas automaticamente!")
