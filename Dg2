_ENV = (getgenv or getrenv or getfenv)()

if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local VIM = game:GetService("VirtualInputManager")
local VU = game:GetService("VirtualUser")
local Player = Players.LocalPlayer

-- =====================================================
-- SISTEMA DE SALVAMENTO JSON
-- =====================================================
local SETTINGS_FILE = "AllanHub_Settings.json"
local DUNGEON_RUNES_FILE = "AllanHub_DungeonRunes.json"

local Settings = {
    -- Dungeon
    AutoFarm = false,
    AutoBuyTicket = false,
    MoveMode = "Tween",
    UseRunesAuto = false,
    AutoRebirth = false,
    
    -- Runas
    RuneSlot1 = "Nenhuma",
    RuneSlot2 = "Nenhuma",
    RuneSlot3 = "Nenhuma",
    RuneSlot4 = "Nenhuma",
    RuneSlot5 = "Nenhuma",
    
    -- Castle
    CastleInf = false,
    AutoCastle = false,
    CastleCreateOnly = false,
    CastleSpeed = "1",
    CastleSpeedEnabled = false,
    EntryFloor = 1,
    ResetFloor = 100,
    
    -- Event Labyrinth
    LabyrinthFloor = "180",
    LabyrinthSpeed = "3",
    LabyrinthSpeedEnabled = false,
    AutoLabyrinth = false
}

local function SaveSettings()
    if not writefile then 
        warn("Executor n√£o suporta writefile!")
        return 
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(Settings)
        writefile(SETTINGS_FILE, encoded)
        print("Configura√ß√µes salvas!")
    end)
    
    if not success then
        warn("Erro ao salvar:", err)
    end
end

local function LoadSettings()
    if not readfile or not isfile then
        warn("Executor n√£o suporta readfile!")
        return
    end
    
    if not isfile(SETTINGS_FILE) then
        print("Criando arquivo de configura√ß√£o...")
        SaveSettings()
        return
    end
    
    local success, err = pcall(function()
        local data = readfile(SETTINGS_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        for key, value in pairs(decoded) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        
        print("Configura√ß√µes carregadas!")
    end)
    
    if not success then
        warn("Erro ao carregar:", err)
    end
end

LoadSettings()

local function SaveDungeonRunes()
    if not writefile then return end
    
    local activerunes = {}
    for slot = 1, 5 do
        local runeName = Settings["RuneSlot" .. slot]
        if runeName and runeName ~= "Nenhuma" then
            activerunes["Slot" .. slot] = runeName
        end
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(activerunes)
        writefile(DUNGEON_RUNES_FILE, encoded)
        print("Runas da dungeon salvas no arquivo persistente!")
    end)
    
    if not success then
        warn("Erro ao salvar runas da dungeon:", err)
    end
end

local function LoadDungeonRunes()
    if not readfile or not isfile then return false end
    
    if not isfile(DUNGEON_RUNES_FILE) then
        print("Nenhum arquivo de runas da dungeon encontrado")
        return false
    end
    
    local success, err = pcall(function()
        local data = readfile(DUNGEON_RUNES_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        print("Carregando runas salvas da dungeon...")
        
        for slotKey, runeName in pairs(decoded) do
            local slotNum = tonumber(string.match(slotKey, "Slot(%d+)"))
            if slotNum then
                Settings["RuneSlot" .. slotNum] = runeName
                print("  Slot " .. slotNum .. ": " .. runeName)
            end
        end
        
        print("Runas da dungeon carregadas com sucesso!")
    end)
    
    if not success then
        warn("Erro ao carregar runas da dungeon:", err)
        return false
    end
    
    return true
end

local function ClearDungeonRunes()
    if not delfile or not isfile then return end
    
    if isfile(DUNGEON_RUNES_FILE) then
        delfile(DUNGEON_RUNES_FILE)
        print("Arquivo de runas da dungeon limpo!")
    end
end

-- CARREGAR RUNAS DA DUNGEON SE EXISTIR (PRIORIDADE M√ÅXIMA)
if LoadDungeonRunes() then
    print("Runas da dungeon restauradas do arquivo persistente!")
end

Config = Settings

local lastNotificationTime = 0
local notificationCooldown = 10
local currentTime = tick()

if currentTime - lastNotificationTime >= notificationCooldown then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Allan Hub",
        Text = "Carregando...",
        Duration = 5
    })
    lastNotificationTime = currentTime
end

local BridgeNet2 = require(ReplicatedStorage:WaitForChild("BridgeNet2"))
local DungeonBridge = BridgeNet2.ReferenceBridge("GENERAL_EVENT")

-- FUN√á√ÉO PARA PEGAR O ID DA DUNGEON ATIVA DO PLAYER
local function GetPlayerDungeonId()
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if not infos then return nil end
    
    local dungeons = infos:FindFirstChild("__Dungeons")
    if not dungeons then return nil end
    
    -- Procurar dungeon onde o player √© o l√≠der
    for _, dungeon in ipairs(dungeons:GetChildren()) do
        local leader = dungeon:GetAttribute("Leader")
        if leader == Player.UserId then
            return leader -- O ID da dungeon √© o UserId do l√≠der
        end
    end
    
    return nil
end

local function SafeFire(payload)
    if not DungeonBridge then return end
    
    -- SE FOR A√á√ÉO DE DUNGEON, ADICIONAR O ID DA DUNGEON AUTOMATICAMENTE
    if payload.Event == "DungeonAction" and payload.Action ~= "Create" and payload.Action ~= "BuyTicket" then
        local dungeonId = GetPlayerDungeonId()
        if dungeonId then
            payload.Dungeon = dungeonId
        end
    end
    
    local ok, err = pcall(function()
        DungeonBridge:Fire(payload)
    end)
    if not ok then
        warn("SafeFire error:", err, payload)
    end
end

-- Proteger UI de ser deletada
local function ProtectUI()
    local success = pcall(function()
        if gethui then
            return gethui()
        elseif syn and syn.protect_gui then
            syn.protect_gui(CoreGui)
        end
    end)
end

ProtectUI()

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/allanxsix/Teste/refs/heads/main/uiallanhub"))()

local Main = Library.CreateMain({
    Desc = " _ng.shinichi"
})

local PageDungeon = Main.CreatePage({
    Page_Name = "Dungeon",
    Page_Title = "Dungeon System"
})

local PageCastle = Main.CreatePage({
    Page_Name = "Castle",
    Page_Title = "Castelo Infernal"
})

local PageIslands = Main.CreatePage({
    Page_Name = "Islands",
    Page_Title = "Islands"
})

local PageEvent = Main.CreatePage({
    Page_Name = "Event",
    Page_Title = "Infinite Labyrinth"
})

local PageSettings = Main.CreatePage({
    Page_Name = "Settings",
    Page_Title = "Settings"
})
local SectionEventMain = PageEvent.CreateSection("Infinite Labyrinth")

local SectionDungeonMain = PageDungeon.CreateSection("Main Settings")
local SectionDungeonRunes = PageDungeon.CreateSection("Sistema de Runas")
local SectionCastleMain = PageCastle.CreateSection("Castle Settings")
local SectionIslandsMain = PageIslands.CreateSection("Islands")

local function UpdateStatus(text)
    -- Removido para deixar o script mais limpo
end

local CreatingDungeon = false
local DungeonRunning = false
local StartingDungeon = false
local Rebirthing = false
local SpawnConfirmTime = 0
local currentTween = nil

local MAX_RUNE_SLOTS = 5
local RuneSlots = {}
for i = 1, MAX_RUNE_SLOTS do RuneSlots[i] = "" end

local ItemsInfo
pcall(function()
    ItemsInfo = require(ReplicatedStorage:WaitForChild("Indexer"):WaitForChild("ItemsInfo"))
end)

local AvailableRunes = {}

local function ScanRunes()
    table.clear(AvailableRunes)
    if not ItemsInfo then 
        warn("ItemsInfo n√£o encontrado!")
        return 
    end

    print("Escaneando runas...")
    local count = 0

    for id, data in pairs(ItemsInfo) do
        if typeof(data) == "table" then
            local t = tostring(data.Type or "")
            local n = tostring(data.Name or "")
            
            if string.find(string.lower(t), "rune") or string.find(string.lower(n), "rune") then
                table.insert(AvailableRunes, {
                    Id = id,
                    Name = data.Name or tostring(id)
                })
                count = count + 1
            end
        end
    end

    print("Total de runas:", count)
    
    if count == 0 then
        warn("Nenhuma runa detectada!")
    end
end

ScanRunes()

local RuneNames = { "Nenhuma" }
for _, r in ipairs(AvailableRunes) do
    table.insert(RuneNames, r.Name)
end

-- RESTAURAR RUNAS SALVAS DOS SETTINGS
local function RestoreSavedRunes()
    local restoredCount = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local savedRuneName = Settings["RuneSlot" .. slot]
        
        if savedRuneName and savedRuneName ~= "Nenhuma" then
            -- Procurar o ID da runa pelo nome salvo
            for _, rune in ipairs(AvailableRunes) do
                if rune.Name == savedRuneName then
                    RuneSlots[slot] = rune.Id
                    restoredCount = restoredCount + 1
                    print("Runa Slot " .. slot .. " restaurada: " .. savedRuneName .. " (ID: " .. rune.Id .. ")")
                    break
                end
            end
        end
    end
    
    if restoredCount > 0 then
        print("Total de " .. restoredCount .. " runas restauradas das configura√ß√µes salvas!")
    end
    
    return restoredCount
end

-- RESTAURAR AS RUNAS AP√ìS ESCANEAR (agora usa as runas do arquivo persistente)
RestoreSavedRunes()

SectionDungeonMain.CreateToggle({
    Title = "Auto Farm Dungeon",
    Default = Settings.AutoFarm
}, function(v)
    Settings.AutoFarm = v
    SaveSettings()
end)

SectionDungeonMain.CreateToggle({
    Title = "Auto Buy Ticket",
    Default = Settings.AutoBuyTicket
}, function(v)
    Settings.AutoBuyTicket = v
    SaveSettings()
end)

SectionDungeonMain.CreateDropdown({
    Title = "Movement Mode",
    List = { "Tween", "Teleport" },
    Default = Settings.MoveMode
}, function(v)
    Settings.MoveMode = v
    SaveSettings()
end)

SectionDungeonMain.CreateToggle({
    Title = "Auto Rebirth (MAX)",
    Desc = "Faz rebirth automaticamente ao atingir level m√°ximo",
    Default = Settings.AutoRebirth
}, function(v)
    Settings.AutoRebirth = v
    SaveSettings()
end)

for slot = 1, MAX_RUNE_SLOTS do
    SectionDungeonRunes.CreateDropdown({
        Title = "Runa Slot " .. slot,
        List = RuneNames,
        Default = Settings["RuneSlot" .. slot]
    }, function(v)
        Settings["RuneSlot" .. slot] = v
        
        if v == "Nenhuma" then
            RuneSlots[slot] = ""
        else
            for _, r in ipairs(AvailableRunes) do
                if r.Name == v then
                    RuneSlots[slot] = r.Id
                    print("Slot " .. slot .. " configurado: " .. v .. " (ID: " .. r.Id .. ")")
                    break
                end
            end
        end
        
        SaveSettings()
        
        -- SALVAR NO ARQUIVO PERSISTENTE DE RUNAS DA DUNGEON
        if Settings.UseRunesAuto then
            SaveDungeonRunes()
        end
    end)
end

SectionDungeonRunes.CreateToggle({
    Title = "Usar Runas Automaticamente",
    Desc = "Aplica as runas sempre que criar uma dungeon",
    Default = Settings.UseRunesAuto
}, function(v)
    Settings.UseRunesAuto = v
    SaveSettings()
    
    if v then
        -- SALVAR RUNAS NO ARQUIVO PERSISTENTE AO ATIVAR
        SaveDungeonRunes()
        
        local count = 0
        for i = 1, MAX_RUNE_SLOTS do
            if RuneSlots[i] ~= "" then count = count + 1 end
        end
        Library.CreateNoti({
            Title = "Runas Autom√°ticas",
            Desc = "Ativado! " .. count .. " runas ser√£o aplicadas",
            ShowTime = 4
        })
    else
        -- LIMPAR ARQUIVO PERSISTENTE AO DESATIVAR
        ClearDungeonRunes()
        Library.CreateNoti({
            Title = "Runas Autom√°ticas",
            Desc = "Desativado! Arquivo de runas limpo.",
            ShowTime = 4
        })
    end
end)

local EnemiesFolder = workspace.__Main.__Enemies.Server

local function GetClosestEnemy()
    local char = Player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    local best, dist = nil, math.huge

    for _, e in ipairs(EnemiesFolder:GetChildren()) do
        local hp = e:GetAttribute("HP")
        if hp and hp > 0 and e.Position then
            local d = (pos - e.Position).Magnitude
            if d < dist then
                dist = d
                best = e
            end
        end
    end

    return best
end

local function MoveToEnemy(enemy)
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if Settings.MoveMode == "Teleport" then
        if currentTween then currentTween:Cancel() end
        root.CFrame = enemy.CFrame
    else
        if currentTween then currentTween:Cancel() end
        currentTween = TweenService:Create(
            root,
            TweenInfo.new(0.3),
            { CFrame = enemy.CFrame }
        )
        currentTween:Play()
    end
end

local function AttackEnemy(enemy)
    SafeFire({
        PetPos = {},
        AttackType = "All",
        Event = "Attack",
        Enemy = enemy.Name
    })
end

local function BuyDungeonTicket()
    SafeFire({
        Event = "DungeonAction",
        Action = "BuyTicket"
    })
end

-- NOVA FUN√á√ÉO APPLY RUNES COM DETEC√á√ÉO DE ID
local function ApplyRunes()
    if not Settings.UseRunesAuto then 
        return 0 
    end
    
    -- PEGAR ID DA DUNGEON
    local dungeonId = GetPlayerDungeonId()
    if not dungeonId then
        print("ID da dungeon n√£o encontrado - n√£o √© poss√≠vel adicionar runas")
        return 0
    end
    
    print("ID da Dungeon detectado:", dungeonId)
    
    local runesApplied = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local runeId = RuneSlots[slot]
        if runeId ~= "" then
            -- USAR M√âTODO QUE FUNCIONA: AddItems com ID da Dungeon
            SafeFire({
                Dungeon = dungeonId,
                Event = "DungeonAction",
                Action = "AddItems",
                Slot = slot,
                Item = runeId
            })
            runesApplied = runesApplied + 1
            print("Aplicando Runa Slot " .. slot .. ": " .. runeId)
            task.wait(0.4)
        end
    end
    
    return runesApplied
end

local function CreateDungeon()
    if CreatingDungeon or Rebirthing then return end

    CreatingDungeon = true
    StartingDungeon = true
    UpdateStatus("Preparing Dungeon...")

    -- SALVAR RUNAS ANTES DE CRIAR A DUNGEON (caso o jogo recarregue)
    if Settings.UseRunesAuto then
        SaveDungeonRunes()
        print("Runas salvas antes de criar a dungeon")
    end

    -- Comprar ticket
    if Settings.AutoBuyTicket then
        BuyDungeonTicket()
        task.wait(0.8)
    end

    -- Criar dungeon PRIMEIRO
    UpdateStatus("Creating Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Create"
    })
    
    task.wait(1.5)

    -- Aplicar runas DEPOIS de criar (com ID detectado)
    if Settings.UseRunesAuto then
        UpdateStatus("Applying Runes...")
        local runesApplied = ApplyRunes()
        
        if runesApplied > 0 then
            UpdateStatus(runesApplied .. " Runas Ready!")
            task.wait(0.5)
        end
    end

    -- Iniciar dungeon
    UpdateStatus("Starting Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Start"
    })

    task.delay(2, function()
        CreatingDungeon = false
    end)
end

RunService.Heartbeat:Connect(function(dt)
    if not Settings.AutoFarm or Rebirthing then
        DungeonRunning = false
        SpawnConfirmTime = 0
        UpdateStatus("Idle")
        return
    end

    local enemy = GetClosestEnemy()

    if enemy then
        DungeonRunning = true
        StartingDungeon = false
        SpawnConfirmTime = 0
        UpdateStatus("Farming (" .. Settings.MoveMode .. ")")
        MoveToEnemy(enemy)
        AttackEnemy(enemy)
        return
    end

    if DungeonRunning then
        SpawnConfirmTime += dt
        UpdateStatus(("Finalizando Dungeon %.1fs"):format(SpawnConfirmTime))
        if SpawnConfirmTime >= 1.8 then
            DungeonRunning = false
            SpawnConfirmTime = 0
            CreateDungeon()
        end
    else
        CreateDungeon()
    end
end)

local PlayerGui = Player:WaitForChild("PlayerGui")
local ExpText = PlayerGui
    :WaitForChild("Hud")
    :WaitForChild("BottomContainer")
    :WaitForChild("ExpBar")
    :WaitForChild("ExpText")

local function GetLevelInfo()
    local text = ExpText.Text
    if not text then return nil, false end
    local level = tonumber(string.match(text, "Level:%s*(%d+)"))
    
    -- Verifica se o texto cont√©m "MAX" ou "M√ÅXIMO"
    if string.find(text, "MAX") or string.find(text, "M√ÅXIMO") then
        return level, true
    end
    
    -- Verifica se a experi√™ncia necess√°ria √© 0 (level m√°ximo)
    local cur, need = string.match(text, "%((%d+)%/(%d+)%)")
    if cur and need and tonumber(need) == 0 then
        return level, true
    end
    
    return level, false
end

local rebirthCooldown = 0

-- Loop de Stats (PlayerExp a cada 30s)
task.spawn(function()
    while true do
        if Settings.AutoRebirth then
            SafeFire({
                Event = "StatsUp",
                Stats = "PlayerExp",
                Points = 2000
            })
        end
        task.wait(30)
    end
end)

-- Loop de Stats (ShadowRange a cada 40s)
task.spawn(function()
    while true do
        if Settings.AutoRebirth then
            SafeFire({
                Event = "StatsUp",
                Stats = "ShadowRange",
                Points = 400
            })
        end
        task.wait(40)
    end
end)

-- Sistema que simula atividade a cada 10 minutos
task.spawn(function()
    while task.wait(600) do -- 600 segundos = 10 minutos
        VU:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        VU:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        print("Anti-AFK: Atividade simulada")
    end
end)

-- Backup: Tamb√©m detecta quando o Roblox tenta kickar por inatividade
Player.Idled:Connect(function()
    VU:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    VU:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    print("Anti-AFK: Kickar prevenido")
end)

RunService.Heartbeat:Connect(function(dt)
    rebirthCooldown += dt

    if not Settings.AutoRebirth or rebirthCooldown < 10 then return end
    if Rebirthing or CreatingDungeon then return end

    local lvl, isMax = GetLevelInfo()
    
    -- S√≥ faz rebirth se estiver no level m√°ximo
    if isMax then
        print("LEVEL MAX! Fazendo Rebirth...")
        Rebirthing = true
        
        SafeFire({
            Event = "Rebirth"
        })
        
        task.wait(2)
        Rebirthing = false
        rebirthCooldown = 0
    end
end)

local castleInfEnabled = false
local autoCastleEnabled = false
local castleCreateOnlyEnabled = false
local entryFloor = Settings.EntryFloor
local resetFloor = Settings.ResetFloor
local selectedCastleSpeed = Settings.CastleSpeed

-- AUTO F2 + F3
local autoF2F3Enabled = false
local f2f3Mode = "8x"
local F2F3_INTERVALS = {
    ["1x"] = 60,    -- 1 minuto normal
    ["4x"] = 15,    -- 1 minuto acelerado 4x (60/4)
    ["8x"] = 7.5    -- 1 minuto acelerado 8x (60/8)
}
local DELAY_F2_F3 = 1.5
local castleSpeedEnabled = Settings.CastleSpeedEnabled

local function pressKey(key)
    VIM:SendKeyEvent(true, key, false, game)
    task.wait(0.05)
    VIM:SendKeyEvent(false, key, false, game)
end

local function autoF2F3Loop()
    task.spawn(function()
        while autoF2F3Enabled do
            pressKey(Enum.KeyCode.F2)
            task.wait(DELAY_F2_F3)
            pressKey(Enum.KeyCode.F3)
            task.wait(F2F3_INTERVALS[f2f3Mode])
        end
    end)
end

local function getCurrentCastleFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    local current = nil
    for i = 1, 800 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end
    return current
end

local function buyCastleTicket()
    SafeFire({
        Event = "CastleAction",
        Action = "BuyTicket",
        Type = "Gems"
    })
end

local function createCastle()
    SafeFire({
        Event = "CastleAction",
        Action = "Create"
    })
    task.wait(2.5)
end

local function joinCastle(floor)
    SafeFire({
        Event = "CastleAction",
        Action = "Join",
        Floor = tostring(floor or entryFloor),
        Check = true
    })
end

local function findFirePortal()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    for i = 1, 300 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local portal = room:FindFirstChild("FirePortal", true)
            if portal then
                return portal, i
            end
        end
    end
    return nil
end

local function teleportToFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local char = Player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    hrp.CFrame = portal:GetPivot() * CFrame.new(0, 2, -3)
    hrp.Velocity = Vector3.zero
    return true
end

local function activateFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local prompt = portal:FindFirstChildWhichIsA("ProximityPrompt", true)
    if not prompt then return false end

    for _ = 1, 3 do
        pcall(function()
            fireproximityprompt(prompt)
        end)
        task.wait(0.15)
    end
    return true
end

local function farmCastleMobs()
    local mobsKilled = false
    local enemiesFolder = workspace:FindFirstChild("__Main")

    if enemiesFolder then
        enemiesFolder = enemiesFolder:FindFirstChild("__Enemies")
        if enemiesFolder then
            enemiesFolder = enemiesFolder:FindFirstChild("Server")
        end
    end

    if enemiesFolder then
        for _, mob in pairs(enemiesFolder:GetChildren()) do
            if not castleInfEnabled then break end

            local hp = mob:GetAttribute("HP")
            if hp and hp > 0 and mob.Position then
                local char = Player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                
                if hrp then
                    hrp.CFrame = mob.CFrame * CFrame.new(0, 0, 3)

                    SafeFire({
                        PetPos = {},
                        AttackType = "All",
                        Event = "Attack",
                        Enemy = mob.Name
                    })

                    while castleInfEnabled and mob.Parent do
                        local currentHP = mob:GetAttribute("HP")
                        if not currentHP or currentHP <= 0 then
                            break
                        end
                        task.wait(0.2)
                    end

                    mobsKilled = true
                end
            end
        end
    end

    return mobsKilled
end

local function castleInfLoop()
    task.spawn(function()
        while castleInfEnabled do
            local hasMobs = farmCastleMobs()
            if not hasMobs then
                if teleportToFirePortal() then
                    task.wait(1)
                    activateFirePortal()
                end
            end
            task.wait(0.4)
        end
    end)
end

local function autoCastleLoop()
    task.spawn(function()
        while autoCastleEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            else
                if currentFloor >= resetFloor then
                    buyCastleTicket()
                    task.wait(1)
                    createCastle()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    farmCastleMobs()
                end
            end
            task.wait(0.5)
        end
    end)
end

local function castleCreateOnlyLoop()
    task.spawn(function()
        while castleCreateOnlyEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            end
            task.wait(1)
        end
    end)
end

-- =====================================================
-- CASTLE UI
-- =====================================================
SectionCastleMain.CreateBox({
    Title = "Andar de Entrada",
    Placeholder = "Digite o andar",
    Default = tostring(Settings.EntryFloor),
    Number = true
}, function(v)
    local n = tonumber(v)
    if n then
        entryFloor = n
        Settings.EntryFloor = n
        SaveSettings()
    end
end)

SectionCastleMain.CreateBox({
    Title = "Andar de Reset",
    Placeholder = "Digite o andar",
    Default = tostring(Settings.ResetFloor),
    Number = true
}, function(v)
    local n = tonumber(v)
    if n then
        resetFloor = n
        Settings.ResetFloor = n
        SaveSettings()
    end
end)

SectionCastleMain.CreateToggle({
    Title = "Castle INF (Farm + Portal)",
    Default = Settings.CastleInf
}, function(v)
    castleInfEnabled = v
    Settings.CastleInf = v
    SaveSettings()
    if v then castleInfLoop() end
end)

SectionCastleMain.CreateToggle({
    Title = "Auto Castle (Create + Reset)",
    Default = Settings.AutoCastle
}, function(v)
    autoCastleEnabled = v
    Settings.AutoCastle = v
    SaveSettings()
    if v then autoCastleLoop() end
end)

SectionCastleMain.CreateToggle({
    Title = "Auto Castle (Criar Apenas)",
    Default = Settings.CastleCreateOnly
}, function(v)
    castleCreateOnlyEnabled = v
    Settings.CastleCreateOnly = v
    SaveSettings()
    if v then castleCreateOnlyLoop() end
end)

SectionCastleMain.CreateDropdown({
    Title = "Speed do Castelo",
    List = {"1", "2", "4"},
    Default = Settings.CastleSpeed
}, function(v)
    selectedCastleSpeed = v
    Settings.CastleSpeed = v
    SaveSettings()
    
    if castleSpeedEnabled then
        SafeFire({
            Event = "CastleAction",
            Action = "SpeedUp",
            Speed = tonumber(v)
        })
    end
end)

SectionCastleMain.CreateToggle({
    Title = "Ativar Speed do Castelo",
    Default = Settings.CastleSpeedEnabled
}, function(v)
    castleSpeedEnabled = v
    Settings.CastleSpeedEnabled = v
    SaveSettings()
    
    if v then
        SafeFire({
            Event = "CastleAction",
            Action = "SpeedUp",
            Speed = tonumber(selectedCastleSpeed)
        })
    end
end)

SectionCastleMain.CreateDropdown({
    Title = "Modo Auto F2 + F3",
    List = {"1x", "4x", "8x"},
    Default = "8x"
}, function(v)
    f2f3Mode = v
end)

SectionCastleMain.CreateToggle({
    Title = "Ativar Auto F2 + F3",
    Desc = "Pressiona F2 e F3 automaticamente"
}, function(v)
    autoF2F3Enabled = v
    if v then
        autoF2F3Loop()
        Library.CreateNoti({
            Title = "Auto F2+F3",
            Desc = "Ativado no modo " .. f2f3Mode,
            ShowTime = 3
        })
    end
end)

local SelectedIslandName = nil
local IslandMap = {}
local function GetWorld()
local extra = workspace:FindFirstChild("__Extra")
if not extra then return nil end
return extra:FindFirstChild("__Spawns")
end
local function GetIslandDisplayName(island)
if island:GetAttribute("DisplayName") then return island:GetAttribute("DisplayName") end
if island:GetAttribute("Name") then return island:GetAttribute("Name") end
for _, child in ipairs(island:GetChildren()) do
if child:IsA("StringValue") then
return child.Value
end
end
return island.Name
end
local function ScanIslands()
table.clear(IslandMap)
local World = GetWorld()
if not World then return {} end
local list = {}
for _, island in ipairs(World:GetChildren()) do
local displayName = GetIslandDisplayName(island)
IslandMap[displayName] = island
table.insert(list, displayName)
end
table.sort(list)
return list
end
local function TeleportToIsland(islandModel)
local char = Players.LocalPlayer.Character
if not char or not char:FindFirstChild("HumanoidRootPart") then return end
local hrp = char.HumanoidRootPart
if islandModel.GetPivot then
hrp.CFrame = islandModel:GetPivot() * CFrame.new(0, 10, 0)
elseif islandModel.PrimaryPart then
hrp.CFrame = islandModel.PrimaryPart.CFrame * CFrame.new(0, 10, 0)
elseif islandModel:IsA("BasePart") then
hrp.CFrame = islandModel.CFrame * CFrame.new(0, 10, 0)
end
end
SectionIslandsMain.CreateDropdown({
    Title = "Ilhas Detectadas",
    List = ScanIslands()
}, function(value)
    SelectedIslandName = value
end)

SectionIslandsMain.CreateButton({
    Title = "Teleportar Ilha Selecionada"
}, function()
    if not SelectedIslandName then
        Library.CreateNoti({
            Title = "Erro",
            Desc = "Nenhuma ilha selecionada",
            ShowTime = 3
        })
        return
    end
    local islandModel = IslandMap[SelectedIslandName]
    if islandModel then
        TeleportToIsland(islandModel)
        Library.CreateNoti({
            Title = "Teleport",
            Desc = "Voc√™ foi para " .. SelectedIslandName,
            ShowTime = 3
        })
    end
end)

-- Infinite Labyrinth
local selectedLabyrinthFloor = Settings.LabyrinthFloor
local selectedLabyrinthSpeed = Settings.LabyrinthSpeed
local autoLabyrinthEnabled = Settings.AutoLabyrinth
local creatingLabyrinth = false
local labyrinthSpeedEnabled = Settings.LabyrinthSpeedEnabled
local labyrinthSessionActive = false
local autoSpeedLoopLabyrinth = false
local ultimaCriacaoLabirinto = 0
local ultimaCriacaoLabirinto = 0

-- Fun√ß√£o para pegar o nome do mundo atual
local function GetCurrentWorldName()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end
    return world.Name
end

-- Fun√ß√£o melhorada para verificar se est√° dentro do labirinto infinito
local function IsInsideLabyrinth()
    local worldName = GetCurrentWorldName()
    
    -- Log do mundo atual para debug
    if worldName then
        print("[Labirinto Debug] Mundo atual: " .. worldName)
    end
    
    -- VERIFICA√á√ÉO 1: Objeto InfiniteLabyrinth no workspace
    local main = workspace:FindFirstChild("__Main")
    if main then
        local world = main:FindFirstChild("__World")
        if world then
            local infiniteLabyrinth = world:FindFirstChild("InfiniteLabyrinth")
            if infiniteLabyrinth then
                print("[Labirinto Debug] ‚úì DENTRO - Detectado objeto InfiniteLabyrinth no workspace")
                return true
            end
        end
    end
    
    -- VERIFICA√á√ÉO 2: Nome do mundo
    if worldName and (worldName == "InfiniteLabyrinth" or worldName == "LabyrinthInfinite" or worldName:find("Labyrinth")) then
        print("[Labirinto Debug] ‚úì DENTRO - Detectado pelo nome do mundo: " .. worldName)
        return true
    end
    
    -- VERIFICA√á√ÉO 3: ReplicatedStorage
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if infos then
        local labyrinth = infos:FindFirstChild("__InfiniteLabyrinth")
        if labyrinth then
            for _, lab in ipairs(labyrinth:GetChildren()) do
                local leader = lab:GetAttribute("Leader")
                if leader == Player.UserId then
                    print("[Labirinto Debug] ‚úì DENTRO - Detectado pelo ReplicatedStorage (Leader)")
                    return true
                end
            end
        end
    end
    
    -- VERIFICA√á√ÉO 4: Altitude do player
    if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
        local position = Player.Character.HumanoidRootPart.Position
        if position.Y > 5000 then
            print("[Labirinto Debug] ‚úì DENTRO - Detectado pela altitude (Y > 5000)")
            return true
        end
    end
    
    print("[Labirinto Debug] ‚úó FORA DO LABIRINTO")
    return false
end

-- Fun√ß√£o para aplicar velocidade
local function aplicarVelocidadeLabirinto()
    if not IsInsideLabyrinth() then return end
    
    SafeFire({
        Speed = tonumber(selectedLabyrinthSpeed),
        Event = "InfiniteLabyrinthAction",
        Action = "SpeedUp"
    })
end

-- Auto velocidade com loop
local function iniciarAutoVelocidadeLabirinto()
    if autoSpeedLoopLabyrinth then return end
    autoSpeedLoopLabyrinth = true
    
    task.spawn(function()
        while labyrinthSpeedEnabled and autoSpeedLoopLabyrinth and labyrinthSessionActive do
            if IsInsideLabyrinth() then
                aplicarVelocidadeLabirinto()
            end
            task.wait(10)
        end
        autoSpeedLoopLabyrinth = false
    end)
end

-- Parar auto velocidade
local function pararAutoVelocidadeLabirinto()
    labyrinthSpeedEnabled = false
    autoSpeedLoopLabyrinth = false
end

-- Monitorar sa√≠da do labirinto
local function monitorarSaidaLabirinto()
    task.spawn(function()
        -- Per√≠odo de gra√ßa de 30 segundos ap√≥s entrar (evita falsos positivos por lag)
        print("[Labirinto] Iniciando monitoramento (30s de per√≠odo de gra√ßa)...")
        task.wait(30)
        
        local tentativasConsecutivas = 0
        local maxTentativas = 5
        
        while labyrinthSessionActive do
            local dentroDoLabirinto = IsInsideLabyrinth()
            
            if not dentroDoLabirinto then
                tentativasConsecutivas += 1
                print("[Labirinto] Fora do labirinto - Tentativa " .. tentativasConsecutivas .. "/" .. maxTentativas)
                
                if tentativasConsecutivas >= maxTentativas then
                    print("[Labirinto] Portal destru√≠do confirmado! Recriando...")
                    labyrinthSessionActive = false
                    pararAutoVelocidadeLabirinto()
                    
                    if autoLabyrinthEnabled then
                        task.wait(5)
                        RecreateLabyrinth()
                    end
                    break
                end
            else
                tentativasConsecutivas = 0
            end
            
            task.wait(5)
        end
    end)
end

-- Resetar estado da sess√£o
local function resetarEstadoLabirinto()
    labyrinthSessionActive = false
    pararAutoVelocidadeLabirinto()
end

-- Fun√ß√£o para recriar o labirinto
local function RecreateLabyrinth()
    if creatingLabyrinth then 
        print("[Labirinto] ‚è∏Ô∏è J√° est√° criando um labirinto, aguarde...")
        return 
    end
    
    -- VERIFICA√á√ÉO CR√çTICA: Se j√° est√° dentro, N√ÉO recriar
    if IsInsideLabyrinth() then
        print("[Labirinto] ‚õî J√Å EST√Å DENTRO DO LABIRINTO! Cancelando recria√ß√£o.")
        labyrinthSessionActive = true
        
        -- Apenas ativar velocidade e monitoramento se necess√°rio
        if labyrinthSpeedEnabled and not autoSpeedLoopLabyrinth then
            aplicarVelocidadeLabirinto()
            iniciarAutoVelocidadeLabirinto()
        end
        
        if not labyrinthSessionActive then
            monitorarSaidaLabirinto()
        end
        
        return
    end
    
    -- NOVA VERIFICA√á√ÉO: Se j√° existe um portal ativo no ReplicatedStorage
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if infos then
        local labyrinth = infos:FindFirstChild("__InfiniteLabyrinth")
        if labyrinth then
            for _, lab in ipairs(labyrinth:GetChildren()) do
                local leader = lab:GetAttribute("Leader")
                if leader == Player.UserId then
                    print("[Labirinto] ‚õî Portal ativo encontrado no ReplicatedStorage! Cancelando recria√ß√£o.")
                    return
                end
            end
        end
    end
    
    -- COOLDOWN: Evitar m√∫ltiplas cria√ß√µes em curto per√≠odo
    local tempoAtual = tick()
    if tempoAtual - ultimaCriacaoLabirinto < 10 then
        local tempoRestante = math.ceil(10 - (tempoAtual - ultimaCriacaoLabirinto))
        print("[Labirinto] ‚è±Ô∏è Cooldown ativo! Aguarde " .. tempoRestante .. " segundos.")
        return
    end
    
    ultimaCriacaoLabirinto = tempoAtual
    creatingLabyrinth = true
    labyrinthSessionActive = true
    
    print("[Labirinto] üî® Criando labirinto no andar " .. selectedLabyrinthFloor .. "...")
    print("[Labirinto] Mundo atual antes de criar: " .. (GetCurrentWorldName() or "Desconhecido"))
    
    -- Criar labirinto
    SafeFire({
        Event = "InfiniteLabyrinthAction",
        Action = "Create"
    })
    
    task.wait(2)
    
    -- Iniciar labirinto
    SafeFire({
        Dungeon = Player.UserId,
        Check = selectedLabyrinthFloor,
        Event = "InfiniteLabyrinthAction",
        Action = "Start"
    })
    
    task.wait(3)
    
    -- Verificar se entrou com sucesso
    local startSuccess = false
    for tentativa = 1, 3 do
        if IsInsideLabyrinth() then
            startSuccess = true
            print("[Labirinto] Entrada confirmada!")
            break
        end
        task.wait(2)
    end
    
    if not startSuccess then
        print("[Labirinto] Falha ao entrar. Resetando...")
        resetarEstadoLabirinto()
        creatingLabyrinth = false
        return
    end
    
    print("[Labirinto] Labirinto criado com sucesso!")
    
    -- Aplicar velocidade se ativada
    if labyrinthSpeedEnabled then
        task.wait(1)
        aplicarVelocidadeLabirinto()
        iniciarAutoVelocidadeLabirinto()
    end
    
    -- Iniciar monitoramento
    monitorarSaidaLabirinto()
    
    creatingLabyrinth = false
end

-- Iniciar labirinto infinito
local function iniciarLabirintoInfinito()
    print("[Labirinto] iniciarLabirintoInfinito() chamado")
    
    local dentroDoLabirinto = IsInsideLabyrinth()
    local worldName = GetCurrentWorldName()
    
    print("[Labirinto] Estado atual:")
    print("  - Sess√£o ativa: " .. tostring(labyrinthSessionActive))
    print("  - Dentro do labirinto: " .. tostring(dentroDoLabirinto))
    print("  - Mundo atual: " .. (worldName or "Desconhecido"))
    
    -- PROTE√á√ÉO CR√çTICA: Se j√° est√° dentro, NUNCA criar novo
    if dentroDoLabirinto then
        print("[Labirinto] ‚ö†Ô∏è J√Å EST√Å DENTRO! Cancelando cria√ß√£o para evitar duplica√ß√£o.")
        
        if not labyrinthSessionActive then
            labyrinthSessionActive = true
            
            if labyrinthSpeedEnabled then
                task.wait(1)
                aplicarVelocidadeLabirinto()
                iniciarAutoVelocidadeLabirinto()
            end
            
            monitorarSaidaLabirinto()
        end
        return
    end
    
    -- Verificar se h√° portal ativo no ReplicatedStorage
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if infos then
        local labyrinth = infos:FindFirstChild("__InfiniteLabyrinth")
        if labyrinth then
            for _, lab in ipairs(labyrinth:GetChildren()) do
                local leader = lab:GetAttribute("Leader")
                if leader == Player.UserId then
                    print("[Labirinto] ‚ö†Ô∏è Portal ativo detectado! Cancelando cria√ß√£o.")
                    return
                end
            end
        end
    end
    
    -- Se sess√£o j√° est√° ativa mas n√£o est√° dentro, resetar primeiro
    if labyrinthSessionActive then
        print("[Labirinto] Sess√£o ativa mas n√£o est√° dentro. Resetando...")
        resetarEstadoLabirinto()
        task.wait(2)
    end
    
    -- Se n√£o est√° dentro e n√£o h√° sess√£o ativa, criar novo
    print("[Labirinto] ‚úì Condi√ß√µes OK. Iniciando cria√ß√£o...")
    RecreateLabyrinth()
end

-- Gerar lista de andares de 1 at√© 360 (de 30 em 30)
local function GenerateFloorList()
    local floors = {}
    for i = 1, 360, 30 do
        table.insert(floors, tostring(i))
    end
    return floors
end

SectionEventMain.CreateDropdown({
    Title = "Selecionar Andar",
    List = GenerateFloorList(),
    Default = Settings.LabyrinthFloor
}, function(v)
    selectedLabyrinthFloor = v
    Settings.LabyrinthFloor = v
    SaveSettings()
end)

SectionEventMain.CreateDropdown({
    Title = "Selecionar Speed",
    List = {"1", "3", "6"},
    Default = Settings.LabyrinthSpeed
}, function(v)
    selectedLabyrinthSpeed = v
    Settings.LabyrinthSpeed = v
    SaveSettings()
    
    if labyrinthSpeedEnabled then
        SafeFire({
            Speed = tonumber(selectedLabyrinthSpeed),
            Event = "InfiniteLabyrinthAction",
            Action = "SpeedUp"
        })
    end
end)

SectionEventMain.CreateToggle({
    Title = "Ativar Speed do Labirinto",
    Default = Settings.LabyrinthSpeedEnabled
}, function(v)
    labyrinthSpeedEnabled = v
    Settings.LabyrinthSpeedEnabled = v
    SaveSettings()
    
    if v then
        if IsInsideLabyrinth() then
            aplicarVelocidadeLabirinto()
            iniciarAutoVelocidadeLabirinto()
            
            Library.CreateNoti({
                Title = "Speed Labirinto",
                Desc = "Velocidade x" .. selectedLabyrinthSpeed .. " ativada com auto-reaplica!",
                ShowTime = 3
            })
        else
            Library.CreateNoti({
                Title = "Speed Labirinto",
                Desc = "Entre no labirinto para ativar a speed!",
                ShowTime = 3
            })
        end
    else
        pararAutoVelocidadeLabirinto()
    end
end)

SectionEventMain.CreateToggle({
    Title = "Auto Criar e Iniciar",
    Desc = "Cria e recria automaticamente quando portal for destru√≠do",
    Default = Settings.AutoLabyrinth
}, function(v)
    autoLabyrinthEnabled = v
    Settings.AutoLabyrinth = v
    SaveSettings()
    
    if v then
        -- Esperar 2 segundos para garantir que o jogo carregou completamente
        task.wait(2)
        
        -- Verificar se j√° est√° dentro ANTES de iniciar
        if IsInsideLabyrinth() then
            print("[Labirinto] DETECTADO: J√° est√° dentro ao ativar toggle!")
            labyrinthSessionActive = true
            
            -- Apenas ativar sistemas de suporte
            if labyrinthSpeedEnabled then
                task.wait(1)
                aplicarVelocidadeLabirinto()
                iniciarAutoVelocidadeLabirinto()
            end
            
            monitorarSaidaLabirinto()
            
            Library.CreateNoti({
                Title = "Auto Labirinto",
                Desc = "J√° est√° dentro! Monitoramento ativado.",
                ShowTime = 4
            })
        else
            -- N√£o est√° dentro, pode iniciar normalmente
            iniciarLabirintoInfinito()
            Library.CreateNoti({
                Title = "Auto Labirinto",
                Desc = "Sistema autom√°tico ativado!\nRecriar ao destruir portal: SIM",
                ShowTime = 4
            })
        end
    else
        resetarEstadoLabirinto()
        Library.CreateNoti({
            Title = "Auto Labirinto",
            Desc = "Sistema autom√°tico desativado!",
            ShowTime = 3
        })
    end
end)

local SectionSettings = PageSettings.CreateSection("Config")

SectionSettings.CreateLabel({
    Title = "Sistema de Salvamento\nSuas configura√ß√µes s√£o salvas automaticamente!"
})

SectionSettings.CreateButton({
    Title = "Salvar Configura√ß√µes"
}, function()
    SaveSettings()
    Library.CreateNoti({
        Title = "Salvamento",
        Desc = "Configura√ß√µes salvas com sucesso!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Recarregar Configura√ß√µes"
}, function()
    LoadSettings()
    Library.CreateNoti({
        Title = "Salvamento",
        Desc = "Configura√ß√µes recarregadas!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Resetar Todas Configura√ß√µes"
}, function()
    if delfile and isfile(SETTINGS_FILE) then
        delfile(SETTINGS_FILE)
    end
    
    for key in pairs(Settings) do
        if key:find("RuneSlot") then
            Settings[key] = "Nenhuma"
        elseif type(Settings[key]) == "boolean" then
            Settings[key] = false
        elseif key == "MoveMode" then
            Settings[key] = "Tween"
        elseif key == "CastleSpeed" then
            Settings[key] = "1"
        elseif key == "EntryFloor" then
            Settings[key] = 1
        elseif key == "ResetFloor" then
            Settings[key] = 100
        elseif key == "LabyrinthFloor" then
            Settings[key] = "180"
        elseif key == "LabyrinthSpeed" then
            Settings[key] = "3"
        end
    end
    
    SaveSettings()
    
    Library.CreateNoti({
        Title = "Resetado",
        Desc = "Configura√ß√µes resetadas com sucesso!",
        ShowTime = 3
    })
end)

SectionSettings.CreateButton({
    Title = "Reconectar Servidor"
}, function()
    game:GetService("TeleportService"):Teleport(game.PlaceId, Player)
end)

Library.CreateNoti({
    Title = "Allan Hub V2",
    Desc = "Script carregado com sucesso!\nSistema de salvamento ativo\nRunas detectadas: " .. #AvailableRunes,
    ShowTime = 6
})

print("ALLAN HUB V2 CARREGADO")
print("Sistema de salvamento: ATIVO")
print("Runas detectadas: " .. #AvailableRunes)
print("Detec√ß√£o autom√°tica de ID da dungeon: ATIVO")
print("Todas as configura√ß√µes ser√£o salvas automaticamente!")
