-- =====================================================
-- SERVICES
-- =====================================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer

-- =====================================================
-- SISTEMA DE SALVAMENTO JSON
-- =====================================================
local SETTINGS_FILE = "AllanHub_Settings.json"

local Settings = {
    -- Dungeon
    AutoFarm = false,
    AutoBuyTicket = false,
    MoveMode = "Tween",
    UseRunesAuto = false,
    AutoRebirth = false,
    
    -- Runas (AGORA SALVA IDs DIRETO)
    RuneSlot1 = "",
    RuneSlot2 = "",
    RuneSlot3 = "",
    RuneSlot4 = "",
    RuneSlot5 = "",
    
    -- Castle
    CastleInf = false,
    AutoCastle = false,
    CastleCreateOnly = false,
    CastleSpeed = "1",
    CastleSpeedEnabled = false,
    EntryFloor = 1,
    ResetFloor = 100
}

local function SaveSettings()
    if not writefile then 
        warn("âš ï¸ Executor nÃ£o suporta writefile!")
        return 
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(Settings)
        writefile(SETTINGS_FILE, encoded)
        print("âœ… ConfiguraÃ§Ãµes salvas!")
    end)
    
    if not success then
        warn("âŒ Erro ao salvar:", err)
    end
end

local function LoadSettings()
    if not readfile or not isfile then
        warn("âš ï¸ Executor nÃ£o suporta readfile!")
        return
    end
    
    if not isfile(SETTINGS_FILE) then
        print("ğŸ“ Criando arquivo de configuraÃ§Ã£o...")
        SaveSettings()
        return
    end
    
    local success, err = pcall(function()
        local data = readfile(SETTINGS_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        for key, value in pairs(decoded) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        
        print("âœ… ConfiguraÃ§Ãµes carregadas!")
    end)
    
    if not success then
        warn("âŒ Erro ao carregar:", err)
    end
end

LoadSettings()

-- =====================================================
-- CONFIG (USA SETTINGS)
-- =====================================================
Config = Settings

-- =====================================================
-- NOTIFICATION
-- =====================================================
local lastNotificationTime = 0
local notificationCooldown = 10
local currentTime = tick()

if currentTime - lastNotificationTime >= notificationCooldown then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Allan Hub",
        Text = "Carregando...",
        Duration = 5
    })
    lastNotificationTime = currentTime
end

-- =====================================================
-- BRIDGENET2
-- =====================================================
local BridgeNet2 = require(ReplicatedStorage:WaitForChild("BridgeNet2"))
local DungeonBridge = BridgeNet2.ReferenceBridge("GENERAL_EVENT")

local function SafeFire(payload)
    if not DungeonBridge then 
        warn("âŒ DungeonBridge nÃ£o disponÃ­vel!")
        return false
    end
    
    -- MOSTRAR PAYLOAD COMPLETO
    print("ğŸ“¦ Payload:", HttpService:JSONEncode(payload))
    
    local ok, err = pcall(function()
        DungeonBridge:Fire(payload)
    end)
    
    if not ok then
        warn("âŒ SafeFire error:", err)
        return false
    end
    
    print("âœ… Evento enviado:", payload.Action or payload.Event)
    return true
end

-- =====================================================
-- FLUENT UI
-- =====================================================
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Bug Hub",
    SubTitle = "By AllanXSix",
    TabWidth = 160,
    Size = UDim2.fromOffset(560, 440),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

SaveManager:SetLibrary(Fluent)
SaveManager:SetFolder("AllanHub")

-- =====================================================
-- TABS
-- =====================================================
local Tabs = {
    Dungeon = Window:AddTab({ Title = "Dungeon", Icon = "swords" }),
}
-- =====================================================
-- STATUS
-- =====================================================
local Status = Tabs.Dungeon:AddParagraph({
    Title = "Status",
    Content = "Idle"
})

-- =====================================================
-- FLAGS / STATES
-- =====================================================
local CreatingDungeon = false
local DungeonRunning = false
local StartingDungeon = false
local Rebirthing = false
local SpawnConfirmTime = 0
local currentTween = nil

-- =====================================================
-- RUNAS (5 SLOTS) - SISTEMA OTIMIZADO
-- =====================================================
local MAX_RUNE_SLOTS = 5
local RuneSlots = {}
local RuneIdToName = {} -- Cache reverso para conversÃ£o rÃ¡pida

local ItemsInfo
pcall(function()
    ItemsInfo = require(ReplicatedStorage:WaitForChild("Indexer"):WaitForChild("ItemsInfo"))
end)

local AvailableRunes = {}

local function ScanRunes()
    table.clear(AvailableRunes)
    table.clear(RuneIdToName)
    
    if not ItemsInfo then 
        warn("âŒ ItemsInfo nÃ£o encontrado!")
        return 
    end

    print("ğŸ” Escaneando runas (mÃ©todo rÃ¡pido)...")
    local count = 0

    for id, data in pairs(ItemsInfo) do
        if typeof(data) == "table" then
            local t = tostring(data.Type or "")
            local n = tostring(data.Name or "")
            
            if string.find(string.lower(t), "rune") or string.find(string.lower(n), "rune") then
                local runeName = data.Name or tostring(id)
                table.insert(AvailableRunes, {
                    Id = id,
                    Name = runeName
                })
                RuneIdToName[id] = runeName -- Cache reverso
                count = count + 1
            end
        end
    end

    print("ğŸ“Š Total de runas encontradas:", count)
    
    -- INICIALIZAR SLOTS VAZIOS PRIMEIRO
    for slot = 1, MAX_RUNE_SLOTS do
        RuneSlots[slot] = ""
    end
    
    -- CARREGAR RUNAS SALVAS (IDs) - SÃ“ SE EXISTIR E FOR VÃLIDO
    for slot = 1, MAX_RUNE_SLOTS do
        local savedId = Settings["RuneSlot" .. slot]
        if savedId and savedId ~= "" and RuneIdToName[savedId] then
            RuneSlots[slot] = savedId
            print("âœ… Slot " .. slot .. " restaurado: " .. RuneIdToName[savedId])
        end
    end
    
    if count == 0 then
        warn("âš ï¸ Nenhuma runa detectada!")
    end
end

ScanRunes()

local RuneNames = { "Nenhuma" }
for _, r in ipairs(AvailableRunes) do
    table.insert(RuneNames, r.Name)
end

-- =====================================================
-- UI DUNGEON
-- =====================================================
Tabs.Dungeon:AddToggle("AutoFarmDungeon", {
    Title = "Auto Farm Dungeon",
    Default = Settings.AutoFarm or false,
    Flag = "AutoFarmDungeon",
    Callback = function(v)
        Settings.AutoFarm = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddToggle("AutoBuyTicket", {
    Title = "Auto Buy Ticket",
    Default = Settings.AutoBuyTicket or false,
    Flag = "AutoBuyTicket",
    Callback = function(v)
        Settings.AutoBuyTicket = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddDropdown("MoveMode", {
    Title = "Movement Mode",
    Values = { "Tween", "Teleport" },
    Default = Settings.MoveMode or "Tween",
    Flag = "MoveMode",
    Callback = function(v)
        Settings.MoveMode = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddToggle("AutoRebirth", {
    Title = "Auto Rebirth (MAX)",
    Description = "Faz rebirth automaticamente ao atingir level mÃ¡ximo",
    Default = Settings.AutoRebirth or false,
    Flag = "AutoRebirth",
    Callback = function(v)
        Settings.AutoRebirth = v
        SaveSettings()
    end
})

-- =====================================================
-- UI RUNAS (AGORA SALVA IDs EM VEZ DE NOMES)
-- =====================================================
Tabs.Dungeon:AddParagraph({
    Title = "ğŸ”® Sistema de Runas",
    Content = "Runas detectadas: " .. #AvailableRunes .. "\nSelecione atÃ© 5 runas abaixo"
})

for slot = 1, MAX_RUNE_SLOTS do
    -- Determinar valor padrÃ£o baseado no ID salvo
    local defaultValue = "Nenhuma"
    local savedId = Settings["RuneSlot" .. slot]
    if savedId and savedId ~= "" then
        defaultValue = RuneIdToName[savedId] or "Nenhuma"
    end
    
    Tabs.Dungeon:AddDropdown("RuneSlot" .. slot, {
        Title = "ğŸ”® Runa Slot " .. slot,
        Values = RuneNames,
        Default = defaultValue,
        Flag = "RuneSlot" .. slot,
        Callback = function(v)
            if v == "Nenhuma" then
                RuneSlots[slot] = ""
                Settings["RuneSlot" .. slot] = ""
            else
                for _, r in ipairs(AvailableRunes) do
                    if r.Name == v then
                        RuneSlots[slot] = r.Id
                        Settings["RuneSlot" .. slot] = r.Id -- SALVA O ID AGORA
                        print("âœ… Slot " .. slot .. " configurado: " .. v .. " (ID: " .. r.Id .. ")")
                        break
                    end
                end
            end
            
            SaveSettings()
        end
    })
end

Tabs.Dungeon:AddToggle("UseRunesAuto", {
    Title = "ğŸ”® Usar Runas Automaticamente",
    Default = Settings.UseRunesAuto or false,
    Flag = "UseRunesAuto",
    Callback = function(v)
        Settings.UseRunesAuto = v
        SaveSettings()
        
        if v then
            local count = 0
            for i = 1, MAX_RUNE_SLOTS do
                if RuneSlots[i] ~= "" then count = count + 1 end
            end
            Fluent:Notify({
                Title = "Runas AutomÃ¡ticas",
                Content = "Ativado! " .. count .. " runas serÃ£o aplicadas",
                Duration = 4
            })
        end
    end
})

Tabs.Dungeon:AddButton({
    Title = "ğŸ”„ Reescanear Runas",
    Description = "Atualiza a lista de runas disponÃ­veis",
    Callback = function()
        ScanRunes()
        RuneNames = {"Nenhuma"}
        for _, r in ipairs(AvailableRunes) do
            table.insert(RuneNames, r.Name)
        end
        Fluent:Notify({
            Title = "Runas",
            Content = "Encontradas " .. #AvailableRunes .. " runas!",
            Duration = 4
        })
    end
})

Tabs.Dungeon:AddButton({
    Title = "ğŸ§ª Testar Adicionar Runa",
    Description = "Testa se consegue adicionar runa manualmente",
    Callback = function()
        print("\nğŸ§ª TESTE MANUAL DE RUNA")
        print("=========================")
        
        local testSlot = 1
        local testRuneId = RuneSlots[1]
        
        if not testRuneId or testRuneId == "" then
            Fluent:Notify({
                Title = "Erro",
                Content = "Configure uma runa no Slot 1 primeiro!",
                Duration = 5
            })
            print("âŒ Slot 1 estÃ¡ vazio!")
            return
        end
        
        print("ğŸ“‹ ConfiguraÃ§Ã£o:")
        print("   Slot:", testSlot)
        print("   Runa ID:", testRuneId)
        print("   Runa Nome:", RuneIdToName[testRuneId] or "Desconhecido")
        
        print("\nğŸ“¤ Enviando evento AddItems...")
        local success = SafeFire({
            Action = "AddItems",
            Slot = testSlot,
            Event = "DungeonAction",
            Item = testRuneId
        })
        
        if success then
            print("âœ… Evento enviado com sucesso!")
            Fluent:Notify({
                Title = "Teste de Runa",
                Content = "Evento enviado! Verifique se a runa foi adicionada no jogo.",
                Duration = 5
            })
        else
            print("âŒ Falha ao enviar evento!")
            Fluent:Notify({
                Title = "Erro",
                Content = "Falha ao enviar evento de runa!",
                Duration = 5
            })
        end
        
        print("=========================\n")
    end
})

-- =====================================================
-- FUNÃ‡Ã•ES AUXILIARES
-- =====================================================
local EnemiesFolder = workspace:WaitForChild("__Main"):WaitForChild("__Enemies"):WaitForChild("Server")

local function GetClosestEnemy()
    local char = Player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    local best, dist = nil, math.huge

    -- Verifica se a pasta de inimigos existe
    if not EnemiesFolder then 
        warn("âš ï¸ Pasta de inimigos nÃ£o encontrada!")
        return nil 
    end

    for _, e in ipairs(EnemiesFolder:GetChildren()) do
        local hp = e:GetAttribute("HP")
        if hp and hp > 0 and e.PrimaryPart then
            local d = (pos - e.PrimaryPart.Position).Magnitude
            if d < dist then
                dist = d
                best = e
            end
        end
    end

    return best
end

local function MoveToEnemy(enemy)
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not root or not enemy or not enemy.PrimaryPart then return end

    local targetCFrame = enemy.PrimaryPart.CFrame * CFrame.new(0, 3, -5)

    if Settings.MoveMode == "Teleport" then
        if currentTween then currentTween:Cancel() end
        root.CFrame = targetCFrame
    else
        if currentTween then currentTween:Cancel() end
        currentTween = TweenService:Create(
            root,
            TweenInfo.new(0.4, Enum.EasingStyle.Linear),
            { CFrame = targetCFrame }
        )
        currentTween:Play()
    end
end

local function AttackEnemy(enemy)
    SafeFire({
        PetPos = {},
        AttackType = "All",
        Event = "Attack",
        Enemy = enemy.Name
    })
end

local function BuyDungeonTicket()
    SafeFire({
        Event = "DungeonAction",
        Action = "BuyTicket"
    })
    print("â†’ Comprando Ticket")
end

-- =====================================================
-- FUNÃ‡Ã•ES DE DUNGEON (FLUXO CORRETO: Create â†’ Add Runes â†’ Start)
-- =====================================================

local function CreateDungeonBase()
    print("ğŸ“¤ Enviando: Create Dungeon")
    local success = SafeFire({
        Event = "DungeonAction",
        Action = "Create"
    })
    if success then
        print("âœ… Create Dungeon enviado com sucesso")
    else
        warn("âŒ Falha ao enviar Create Dungeon")
    end
end

local function ApplyRunes()
    if not Settings.UseRunesAuto then 
        print("âš ï¸ Sistema de runas desativado")
        return 0 
    end
    
    -- CONTAR RUNAS VÃLIDAS PRIMEIRO
    local validRunes = 0
    for slot = 1, MAX_RUNE_SLOTS do
        if RuneSlots[slot] and RuneSlots[slot] ~= "" then
            validRunes = validRunes + 1
        end
    end
    
    if validRunes == 0 then
        print("âš ï¸ Nenhuma runa configurada")
        Status:SetDesc("Sem runas configuradas")
        return 0
    end
    
    print("ğŸ”® " .. validRunes .. " runas serÃ£o aplicadas")
    Status:SetDesc("Aplicando " .. validRunes .. " Runas...")
    
    local runesApplied = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local runeId = RuneSlots[slot]
        if not runeId or runeId == "" then continue end
        
        print("ğŸ“¤ Enviando runa para slot " .. slot .. "...")
        local success = SafeFire({
            Action = "AddItems",
            Slot = slot,
            Event = "DungeonAction",
            Item = runeId
        })
        
        local runeName = RuneIdToName[runeId] or tostring(runeId)
        if success then
            print("âœ… Runa adicionada: " .. runeName .. " (Slot " .. slot .. ")")
            runesApplied = runesApplied + 1
        else
            warn("âŒ Falha ao adicionar runa: " .. runeName)
        end
        
        task.wait(0.5) -- Aumentei o tempo entre runas
    end
    
    if runesApplied > 0 then
        Status:SetDesc("âœ¨ " .. runesApplied .. " runas aplicadas!")
        print("âœ… Total aplicado: " .. runesApplied .. " runas")
        task.wait(0.8)
    end
    
    return runesApplied
end

local function StartDungeon()
    print("ğŸ“¤ Enviando: Start Dungeon")
    Status:SetDesc("Iniciando Dungeon...")
    local success = SafeFire({
        Event = "DungeonAction",
        Action = "Start"
    })
    if success then
        print("âœ… Start Dungeon enviado com sucesso")
    else
        warn("âŒ Falha ao enviar Start Dungeon")
    end
end

local function CreateDungeon()
    if CreatingDungeon then 
        print("â¸ï¸ Dungeon jÃ¡ estÃ¡ sendo criada, aguardando...")
        return 
    end
    if Rebirthing then 
        print("â¸ï¸ Rebirth em progresso, pausando criaÃ§Ã£o de dungeon")
        return 
    end
    
    CreatingDungeon = true
    print("\n" .. string.rep("=", 50))
    print("ğŸ® INICIANDO CRIAÃ‡ÃƒO DE DUNGEON")
    print(string.rep("=", 50))
    Status:SetDesc("Criando nova Dungeon...")
    
    -- 1. Comprar ticket se necessÃ¡rio
    if Settings.AutoBuyTicket then
        print("ğŸ’° Comprando ticket...")
        BuyDungeonTicket()
        task.wait(1.5)
    else
        print("â­ï¸ Auto buy ticket desativado")
    end
    
    -- 2. Criar a dungeon (obrigatÃ³rio antes das runas)
    print("ğŸ—ï¸ Criando base da dungeon...")
    CreateDungeonBase()
    task.wait(1.2) -- AUMENTEI O TEMPO DE ESPERA
    
    -- 3. Aplicar runas
    if Settings.UseRunesAuto then
        print("ğŸ”® Iniciando aplicaÃ§Ã£o de runas...")
        local applied = ApplyRunes()
        print("âœ… Runas aplicadas: " .. applied)
    else
        print("â­ï¸ Sistema de runas desativado")
    end
    
    -- 4. Iniciar
    print("â–¶ï¸ Iniciando dungeon...")
    task.wait(0.5) -- AUMENTEI O TEMPO
    StartDungeon()
    
    print("âœ… SequÃªncia completa enviada!")
    print(string.rep("=", 50) .. "\n")
    
    -- Reset de seguranÃ§a
    task.delay(8, function() -- AUMENTEI O TEMPO DE RESET
        CreatingDungeon = false
        print("ğŸ”“ Flag CreatingDungeon resetada")
    end)
end

-- =====================================================
-- LOOP PRINCIPAL
-- =====================================================
local firstRun = true

RunService.Heartbeat:Connect(function(dt)
    if not Settings.AutoFarm or Rebirthing then
        DungeonRunning = false
        SpawnConfirmTime = 0
        if not CreatingDungeon then
            Status:SetDesc("Idle")
        end
        return
    end

    local enemy = GetClosestEnemy()

    if enemy then
        if not DungeonRunning then
            print("ğŸ‘¹ Inimigos detectados - Modo farming ativado")
        end
        DungeonRunning = true
        SpawnConfirmTime = 0
        firstRun = false
        if not CreatingDungeon then
            Status:SetDesc("Farming (" .. Settings.MoveMode .. ")")
        end
        MoveToEnemy(enemy)
        AttackEnemy(enemy)
        return
    end

    -- SÃ“ ENTRA AQUI SE NÃƒO TEM INIMIGO
    if DungeonRunning then
        SpawnConfirmTime += dt
        if not CreatingDungeon then
            Status:SetDesc(string.format("Aguardando fim (%.1fs)", SpawnConfirmTime))
        end
        
        if SpawnConfirmTime >= 2.3 then
            print("â° Timeout de 2.3s atingido - Nenhum inimigo encontrado")
            DungeonRunning = false
            SpawnConfirmTime = 0
            CreateDungeon()
        end
    elseif not CreatingDungeon then
        -- Primeira execuÃ§Ã£o ou apÃ³s timeout
        if firstRun then
            print("ğŸ¯ Auto Farm ativado - Criando primeira dungeon...")
            firstRun = false
        end
        CreateDungeon()
    end
end)

print("âœ“ Auto Dungeon carregado | Fluxo: Create â†’ Add Runes â†’ Start")
print("ğŸ“Š Runas disponÃ­veis:", #AvailableRunes)
print("ğŸ”® Runas configuradas:")
local configuredCount = 0
for i = 1, MAX_RUNE_SLOTS do
    if RuneSlots[i] and RuneSlots[i] ~= "" then
        configuredCount = configuredCount + 1
        print("   Slot " .. i .. ": " .. (RuneIdToName[RuneSlots[i]] or RuneSlots[i]))
    end
end
if configuredCount == 0 then
    print("   Nenhuma runa configurada ainda")
end

-- Verificar estrutura do workspace
print("\nğŸ” Verificando estrutura do jogo...")
local main = workspace:FindFirstChild("__Main")
if main then
    print("âœ… __Main encontrado")
    local enemies = main:FindFirstChild("__Enemies")
    if enemies then
        print("âœ… __Enemies encontrado")
        local server = enemies:FindFirstChild("Server")
        if server then
            print("âœ… Server encontrado")
            print("   Caminho completo: workspace.__Main.__Enemies.Server")
        else
            warn("âŒ Server nÃ£o encontrado em __Enemies")
            print("   Filhos de __Enemies:", table.concat(enemies:GetChildren():GetNames() or {}, ", "))
        end
    else
        warn("âŒ __Enemies nÃ£o encontrado em __Main")
    end
else
    warn("âŒ __Main nÃ£o encontrado no workspace")
end

-- =====================================================
-- AUTO REBIRTH
-- =====================================================
local rebirthCooldown = 0

RunService.Heartbeat:Connect(function(dt)
    rebirthCooldown += dt

    if not Settings.AutoRebirth or rebirthCooldown < 2 then return end
    if Rebirthing or CreatingDungeon then return end

    local leaderstats = Player:FindFirstChild("leaderstats")
    local rebirths = leaderstats and leaderstats:FindFirstChild("Rebirths")

    if rebirths then
        SafeFire({
            Event = "Rebirth"
        })
        rebirthCooldown = 0
    end
end)
