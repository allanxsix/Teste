_ENV = (getgenv or getrenv or getfenv)()

if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- =====================================================
-- SERVICES
-- =====================================================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer

-- =====================================================
-- SISTEMA DE SALVAMENTO JSON
-- =====================================================
local SETTINGS_FILE = "AllanHub_Settings.json"
local DUNGEON_RUNES_FILE = "AllanHub_DungeonRunes.json"

local Settings = {
    -- Dungeon
    AutoFarm = false,
    AutoBuyTicket = false,
    MoveMode = "Tween",
    UseRunesAuto = false,
    AutoRebirth = false,
    
    -- Runas
    RuneSlot1 = "Nenhuma",
    RuneSlot2 = "Nenhuma",
    RuneSlot3 = "Nenhuma",
    RuneSlot4 = "Nenhuma",
    RuneSlot5 = "Nenhuma",
    
    -- Castle
    CastleInf = false,
    AutoCastle = false,
    CastleCreateOnly = false,
    CastleSpeed = "1",
    CastleSpeedEnabled = false,
    EntryFloor = 1,
    ResetFloor = 100
}

local function SaveSettings()
    if not writefile then 
        warn("‚ö†Ô∏è Executor n√£o suporta writefile!")
        return 
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(Settings)
        writefile(SETTINGS_FILE, encoded)
        print("‚úÖ Configura√ß√µes salvas!")
    end)
    
    if not success then
        warn("‚ùå Erro ao salvar:", err)
    end
end

local function LoadSettings()
    if not readfile or not isfile then
        warn("‚ö†Ô∏è Executor n√£o suporta readfile!")
        return
    end
    
    if not isfile(SETTINGS_FILE) then
        print("üìÅ Criando arquivo de configura√ß√£o...")
        SaveSettings()
        return
    end
    
    local success, err = pcall(function()
        local data = readfile(SETTINGS_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        for key, value in pairs(decoded) do
            if Settings[key] ~= nil then
                Settings[key] = value
            end
        end
        
        print("‚úÖ Configura√ß√µes carregadas!")
    end)
    
    if not success then
        warn("‚ùå Erro ao carregar:", err)
    end
end

LoadSettings()

-- =====================================================
-- SISTEMA DE RUNAS DA DUNGEON (PERSISTENTE)
-- =====================================================
local function SaveDungeonRunes()
    if not writefile then return end
    
    local activerunes = {}
    for slot = 1, 5 do
        local runeName = Settings["RuneSlot" .. slot]
        if runeName and runeName ~= "Nenhuma" then
            activerunes["Slot" .. slot] = runeName
        end
    end
    
    local success, err = pcall(function()
        local encoded = HttpService:JSONEncode(activerunes)
        writefile(DUNGEON_RUNES_FILE, encoded)
        print("‚úÖ Runas da dungeon salvas no arquivo persistente!")
    end)
    
    if not success then
        warn("‚ùå Erro ao salvar runas da dungeon:", err)
    end
end

local function LoadDungeonRunes()
    if not readfile or not isfile then return false end
    
    if not isfile(DUNGEON_RUNES_FILE) then
        print("üìÅ Nenhum arquivo de runas da dungeon encontrado")
        return false
    end
    
    local success, err = pcall(function()
        local data = readfile(DUNGEON_RUNES_FILE)
        local decoded = HttpService:JSONDecode(data)
        
        print("üîÆ Carregando runas salvas da dungeon...")
        
        for slotKey, runeName in pairs(decoded) do
            local slotNum = tonumber(string.match(slotKey, "Slot(%d+)"))
            if slotNum then
                Settings["RuneSlot" .. slotNum] = runeName
                print("  ‚úÖ Slot " .. slotNum .. ": " .. runeName)
            end
        end
        
        print("‚úÖ Runas da dungeon carregadas com sucesso!")
    end)
    
    if not success then
        warn("‚ùå Erro ao carregar runas da dungeon:", err)
        return false
    end
    
    return true
end

local function ClearDungeonRunes()
    if not delfile or not isfile then return end
    
    if isfile(DUNGEON_RUNES_FILE) then
        delfile(DUNGEON_RUNES_FILE)
        print("üóëÔ∏è Arquivo de runas da dungeon limpo!")
    end
end

-- CARREGAR RUNAS DA DUNGEON SE EXISTIR (PRIORIDADE M√ÅXIMA)
if LoadDungeonRunes() then
    print("üîÑ Runas da dungeon restauradas do arquivo persistente!")
end

-- =====================================================
-- CONFIG (USA SETTINGS)
-- =====================================================
Config = Settings

-- =====================================================
-- NOTIFICATION
-- =====================================================
local lastNotificationTime = 0
local notificationCooldown = 10
local currentTime = tick()

if currentTime - lastNotificationTime >= notificationCooldown then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Allan Hub",
        Text = "Carregando...",
        Duration = 5
    })
    lastNotificationTime = currentTime
end

-- =====================================================
-- BRIDGENET2
-- =====================================================
local BridgeNet2 = require(ReplicatedStorage:WaitForChild("BridgeNet2"))
local DungeonBridge = BridgeNet2.ReferenceBridge("GENERAL_EVENT")

-- FUN√á√ÉO PARA PEGAR O ID DA DUNGEON ATIVA DO PLAYER
local function GetPlayerDungeonId()
    local infos = ReplicatedStorage:FindFirstChild("__Infos")
    if not infos then return nil end
    
    local dungeons = infos:FindFirstChild("__Dungeons")
    if not dungeons then return nil end
    
    -- Procurar dungeon onde o player √© o l√≠der
    for _, dungeon in ipairs(dungeons:GetChildren()) do
        local leader = dungeon:GetAttribute("Leader")
        if leader == Player.UserId then
            return leader -- O ID da dungeon √© o UserId do l√≠der
        end
    end
    
    return nil
end

local function SafeFire(payload)
    if not DungeonBridge then return end
    
    -- SE FOR A√á√ÉO DE DUNGEON, ADICIONAR O ID DA DUNGEON AUTOMATICAMENTE
    if payload.Event == "DungeonAction" and payload.Action ~= "Create" and payload.Action ~= "BuyTicket" then
        local dungeonId = GetPlayerDungeonId()
        if dungeonId then
            payload.Dungeon = dungeonId
        end
    end
    
    local ok, err = pcall(function()
        DungeonBridge:Fire(payload)
    end)
    if not ok then
        warn("SafeFire error:", err, payload)
    end
end

-- =====================================================
-- FLUENT UI
-- =====================================================
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Allan Hub V2",
    SubTitle = "Dungeon + Castle + Runes + Save System",
    TabWidth = 160,
    Size = UDim2.fromOffset(560, 440),
    Acrylic = true,
    Theme = "dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

SaveManager:SetLibrary(Fluent)
SaveManager:SetFolder("AllanHub")

-- =====================================================
-- TABS
-- =====================================================
local Tabs = {
    Dungeon = Window:AddTab({ Title = "Dungeon", Icon = "swords" }),
    Castle  = Window:AddTab({ Title = "Castelo Infernal", Icon = "flame" }),
    Islands = Window:AddTab({ Title = "Islands", Icon = "map" }),
    Settings= Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- =====================================================
-- BOT√ÉO MINIMIZE CUSTOMIZADO
-- =====================================================
local playerGui = Player:WaitForChild("PlayerGui")
local existingGui = playerGui:FindFirstChild("CustomScreenGui")
if existingGui then
    existingGui:Destroy()
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "CustomScreenGui"
ScreenGui.Parent = playerGui

local Button = Instance.new("ImageButton")
Button.Name = "CustomButton"
Button.Parent = ScreenGui
Button.Size = UDim2.new(0, 50, 0, 50)
Button.Position = UDim2.new(0.015, 0, 0.02, 20)
Button.BackgroundTransparency = 1
Button.Image = "rbxassetid://112254107346248"

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = Button

Button.MouseButton1Click:Connect(function()
    local VirtualInputManager = game:GetService("VirtualInputManager")
    if VirtualInputManager then
        task.defer(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
        end)
    end
end)

-- =====================================================
-- STATUS
-- =====================================================
local Status = Tabs.Dungeon:AddParagraph({
    Title = "Status",
    Content = "Idle"
})

-- =====================================================
-- FLAGS / STATES
-- =====================================================
local CreatingDungeon = false
local DungeonRunning = false
local StartingDungeon = false
local Rebirthing = false
local SpawnConfirmTime = 0
local currentTween = nil

-- =====================================================
-- RUNAS (5 SLOTS)
-- =====================================================
local MAX_RUNE_SLOTS = 5
local RuneSlots = {}
for i = 1, MAX_RUNE_SLOTS do RuneSlots[i] = "" end

local ItemsInfo
pcall(function()
    ItemsInfo = require(ReplicatedStorage:WaitForChild("Indexer"):WaitForChild("ItemsInfo"))
end)

local AvailableRunes = {}

local function ScanRunes()
    table.clear(AvailableRunes)
    if not ItemsInfo then 
        warn("‚ùå ItemsInfo n√£o encontrado!")
        return 
    end

    print("üîç Escaneando runas...")
    local count = 0

    for id, data in pairs(ItemsInfo) do
        if typeof(data) == "table" then
            local t = tostring(data.Type or "")
            local n = tostring(data.Name or "")
            
            if string.find(string.lower(t), "rune") or string.find(string.lower(n), "rune") then
                table.insert(AvailableRunes, {
                    Id = id,
                    Name = data.Name or tostring(id)
                })
                count = count + 1
            end
        end
    end

    print("üìä Total de runas:", count)
    
    if count == 0 then
        warn("‚ö†Ô∏è Nenhuma runa detectada!")
    end
end

ScanRunes()

local RuneNames = { "Nenhuma" }
for _, r in ipairs(AvailableRunes) do
    table.insert(RuneNames, r.Name)
end

-- RESTAURAR RUNAS SALVAS DOS SETTINGS
local function RestoreSavedRunes()
    local restoredCount = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local savedRuneName = Settings["RuneSlot" .. slot]
        
        if savedRuneName and savedRuneName ~= "Nenhuma" then
            -- Procurar o ID da runa pelo nome salvo
            for _, rune in ipairs(AvailableRunes) do
                if rune.Name == savedRuneName then
                    RuneSlots[slot] = rune.Id
                    restoredCount = restoredCount + 1
                    print("‚úÖ Runa Slot " .. slot .. " restaurada: " .. savedRuneName .. " (ID: " .. rune.Id .. ")")
                    break
                end
            end
        end
    end
    
    if restoredCount > 0 then
        print("üîÆ Total de " .. restoredCount .. " runas restauradas das configura√ß√µes salvas!")
    end
    
    return restoredCount
end

-- RESTAURAR AS RUNAS AP√ìS ESCANEAR (agora usa as runas do arquivo persistente)
RestoreSavedRunes()

-- =====================================================
-- UI DUNGEON
-- =====================================================
Tabs.Dungeon:AddToggle("AutoFarmDungeon", {
    Title = "Auto Farm Dungeon",
    Default = Settings.AutoFarm,
    Flag = "AutoFarmDungeon",
    Callback = function(v)
        Settings.AutoFarm = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddToggle("AutoBuyTicket", {
    Title = "Auto Buy Ticket",
    Default = Settings.AutoBuyTicket,
    Flag = "AutoBuyTicket",
    Callback = function(v)
        Settings.AutoBuyTicket = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddDropdown("MoveMode", {
    Title = "Movement Mode",
    Values = { "Tween", "Teleport" },
    Default = Settings.MoveMode,
    Flag = "MoveMode",
    Callback = function(v)
        Settings.MoveMode = v
        SaveSettings()
    end
})

Tabs.Dungeon:AddToggle("AutoRebirth", {
    Title = "Auto Rebirth (MAX)",
    Description = "Faz rebirth automaticamente ao atingir level m√°ximo",
    Default = Settings.AutoRebirth,
    Flag = "AutoRebirth",
    Callback = function(v)
        Settings.AutoRebirth = v
        SaveSettings()
    end
})

-- =====================================================
-- UI RUNAS
-- =====================================================
Tabs.Dungeon:AddParagraph({
    Title = "üîÆ Sistema de Runas",
    Content = "Runas detectadas: " .. #AvailableRunes .. "\nSelecione at√© 5 runas abaixo"
})

for slot = 1, MAX_RUNE_SLOTS do
    Tabs.Dungeon:AddDropdown("RuneSlot" .. slot, {
        Title = "üîÆ Runa Slot " .. slot,
        Values = RuneNames,
        Default = Settings["RuneSlot" .. slot],
        Flag = "RuneSlot" .. slot,
        Callback = function(v)
            Settings["RuneSlot" .. slot] = v
            
            if v == "Nenhuma" then
                RuneSlots[slot] = ""
            else
                for _, r in ipairs(AvailableRunes) do
                    if r.Name == v then
                        RuneSlots[slot] = r.Id
                        print("‚úÖ Slot " .. slot .. " configurado: " .. v .. " (ID: " .. r.Id .. ")")
                        break
                    end
                end
            end
            
            SaveSettings()
            
            -- SALVAR NO ARQUIVO PERSISTENTE DE RUNAS DA DUNGEON
            if Settings.UseRunesAuto then
                SaveDungeonRunes()
            end
        end
    })
end

Tabs.Dungeon:AddToggle("UseRunesAuto", {
    Title = "üîÆ Usar Runas Automaticamente",
    Description = "Aplica as runas sempre que criar uma dungeon",
    Default = Settings.UseRunesAuto,
    Flag = "UseRunesAuto",
    Callback = function(v)
        Settings.UseRunesAuto = v
        SaveSettings()
        
        if v then
            -- SALVAR RUNAS NO ARQUIVO PERSISTENTE AO ATIVAR
            SaveDungeonRunes()
            
            local count = 0
            for i = 1, MAX_RUNE_SLOTS do
                if RuneSlots[i] ~= "" then count = count + 1 end
            end
            Fluent:Notify({
                Title = "Runas Autom√°ticas",
                Content = "Ativado! " .. count .. " runas ser√£o aplicadas",
                Duration = 4
            })
        else
            -- LIMPAR ARQUIVO PERSISTENTE AO DESATIVAR
            ClearDungeonRunes()
            Fluent:Notify({
                Title = "Runas Autom√°ticas",
                Content = "Desativado! Arquivo de runas limpo.",
                Duration = 4
            })
        end
    end
})

Tabs.Dungeon:AddButton({
    Title = "üîÑ Reescanear Runas",
    Description = "Atualiza a lista de runas dispon√≠veis",
    Callback = function()
        ScanRunes()
        RuneNames = {"Nenhuma"}
        for _, r in ipairs(AvailableRunes) do
            table.insert(RuneNames, r.Name)
        end
        Fluent:Notify({
            Title = "Runas",
            Content = "Encontradas " .. #AvailableRunes .. " runas!",
            Duration = 4
        })
    end
})

-- =====================================================
-- DUNGEON FUNCTIONS
-- =====================================================
local EnemiesFolder = workspace.__Main.__Enemies.Server

local function GetClosestEnemy()
    local char = Player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    local best, dist = nil, math.huge

    for _, e in ipairs(EnemiesFolder:GetChildren()) do
        local hp = e:GetAttribute("HP")
        if hp and hp > 0 and e.Position then
            local d = (pos - e.Position).Magnitude
            if d < dist then
                dist = d
                best = e
            end
        end
    end

    return best
end

local function MoveToEnemy(enemy)
    local root = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if Settings.MoveMode == "Teleport" then
        if currentTween then currentTween:Cancel() end
        root.CFrame = enemy.CFrame
    else
        if currentTween then currentTween:Cancel() end
        currentTween = TweenService:Create(
            root,
            TweenInfo.new(0.3),
            { CFrame = enemy.CFrame }
        )
        currentTween:Play()
    end
end

local function AttackEnemy(enemy)
    SafeFire({
        PetPos = {},
        AttackType = "All",
        Event = "Attack",
        Enemy = enemy.Name
    })
end

local function BuyDungeonTicket()
    SafeFire({
        Event = "DungeonAction",
        Action = "BuyTicket"
    })
end

-- NOVA FUN√á√ÉO APPLY RUNES COM DETEC√á√ÉO DE ID
local function ApplyRunes()
    if not Settings.UseRunesAuto then 
        return 0 
    end
    
    -- PEGAR ID DA DUNGEON
    local dungeonId = GetPlayerDungeonId()
    if not dungeonId then
        print("‚ùå ID da dungeon n√£o encontrado - n√£o √© poss√≠vel adicionar runas")
        return 0
    end
    
    print("üîë ID da Dungeon detectado:", dungeonId)
    
    local runesApplied = 0
    
    for slot = 1, MAX_RUNE_SLOTS do
        local runeId = RuneSlots[slot]
        if runeId ~= "" then
            -- USAR M√âTODO QUE FUNCIONA: AddItems com ID da Dungeon
            SafeFire({
                Dungeon = dungeonId,
                Event = "DungeonAction",
                Action = "AddItems",
                Slot = slot,
                Item = runeId
            })
            runesApplied = runesApplied + 1
            print("‚úÖ Aplicando Runa Slot " .. slot .. ": " .. runeId)
            task.wait(0.4)
        end
    end
    
    return runesApplied
end

local function CreateDungeon()
    if CreatingDungeon or Rebirthing then return end

    CreatingDungeon = true
    StartingDungeon = true
    Status:SetDesc("Preparing Dungeon...")

    -- SALVAR RUNAS ANTES DE CRIAR A DUNGEON (caso o jogo recarregue)
    if Settings.UseRunesAuto then
        SaveDungeonRunes()
        print("üíæ Runas salvas antes de criar a dungeon")
    end

    -- Comprar ticket
    if Settings.AutoBuyTicket then
        BuyDungeonTicket()
        task.wait(0.8)
    end

    -- Criar dungeon PRIMEIRO
    Status:SetDesc("Creating Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Create"
    })
    
    task.wait(1.5)

    -- Aplicar runas DEPOIS de criar (com ID detectado)
    if Settings.UseRunesAuto then
        Status:SetDesc("Applying Runes...")
        local runesApplied = ApplyRunes()
        
        if runesApplied > 0 then
            Status:SetDesc("‚ú® " .. runesApplied .. " Runas Ready!")
            task.wait(0.5)
        end
    end

    -- Iniciar dungeon
    Status:SetDesc("Starting Dungeon...")
    SafeFire({
        Event = "DungeonAction",
        Action = "Start"
    })

    task.delay(2, function()
        CreatingDungeon = false
    end)
end

-- =====================================================
-- AUTO DUNGEON LOOP
-- =====================================================
RunService.Heartbeat:Connect(function(dt)
    if not Settings.AutoFarm or Rebirthing then
        DungeonRunning = false
        SpawnConfirmTime = 0
        Status:SetDesc("Idle")
        return
    end

    local enemy = GetClosestEnemy()

    if enemy then
        DungeonRunning = true
        StartingDungeon = false
        SpawnConfirmTime = 0
        Status:SetDesc("Farming (" .. Settings.MoveMode .. ")")
        MoveToEnemy(enemy)
        AttackEnemy(enemy)
        return
    end

    if DungeonRunning then
        SpawnConfirmTime += dt
        Status:SetDesc(("Finalizando Dungeon %.1fs"):format(SpawnConfirmTime))
        if SpawnConfirmTime >= 1.8 then
            DungeonRunning = false
            SpawnConfirmTime = 0
            CreateDungeon()
        end
    else
        CreateDungeon()
    end
end)

-- =====================================================
-- AUTO REBIRTH
-- =====================================================
local rebirthCooldown = 0

RunService.Heartbeat:Connect(function(dt)
    rebirthCooldown += dt

    if not Settings.AutoRebirth or rebirthCooldown < 2 then return end
    if Rebirthing or CreatingDungeon then return end

    local leaderstats = Player:FindFirstChild("leaderstats")
    local rebirths = leaderstats and leaderstats:FindFirstChild("Rebirths")

    if rebirths then
        SafeFire({
            Event = "Rebirth"
        })
        rebirthCooldown = 0
    end
end)

-- =====================================================
-- CASTLE VARIABLES
-- =====================================================
local castleInfEnabled = false
local autoCastleEnabled = false
local castleCreateOnlyEnabled = false
local entryFloor = Settings.EntryFloor
local resetFloor = Settings.ResetFloor
local selectedCastleSpeed = Settings.CastleSpeed
local castleSpeedEnabled = Settings.CastleSpeedEnabled

-- =====================================================
-- CASTLE FUNCTIONS
-- =====================================================
local function getCurrentCastleFloor()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    local current = nil
    for i = 1, 800 do
        if world:FindFirstChild("Room_" .. i) then
            current = i
        end
    end
    return current
end

local function buyCastleTicket()
    SafeFire({
        Event = "CastleAction",
        Action = "BuyTicket",
        Type = "Gems"
    })
end

local function createCastle()
    SafeFire({
        Event = "CastleAction",
        Action = "Create"
    })
    task.wait(2.5)
end

local function joinCastle(floor)
    SafeFire({
        Event = "CastleAction",
        Action = "Join",
        Floor = tostring(floor or entryFloor),
        Check = true
    })
end

local function findFirePortal()
    local main = workspace:FindFirstChild("__Main")
    if not main then return nil end
    local world = main:FindFirstChild("__World")
    if not world then return nil end

    for i = 1, 300 do
        local room = world:FindFirstChild("Room_" .. i)
        if room then
            local portal = room:FindFirstChild("FirePortal", true)
            if portal then
                return portal, i
            end
        end
    end
    return nil
end

local function teleportToFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local char = Player.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    hrp.CFrame = portal:GetPivot() * CFrame.new(0, 2, -3)
    hrp.Velocity = Vector3.zero
    return true
end

local function activateFirePortal()
    local portal = findFirePortal()
    if not portal then return false end

    local prompt = portal:FindFirstChildWhichIsA("ProximityPrompt", true)
    if not prompt then return false end

    for _ = 1, 3 do
        pcall(function()
            fireproximityprompt(prompt)
        end)
        task.wait(0.15)
    end
    return true
end

local function farmCastleMobs()
    local mobsKilled = false
    local enemiesFolder = workspace:FindFirstChild("__Main")

    if enemiesFolder then
        enemiesFolder = enemiesFolder:FindFirstChild("__Enemies")
        if enemiesFolder then
            enemiesFolder = enemiesFolder:FindFirstChild("Server")
        end
    end

    if enemiesFolder then
        for _, mob in pairs(enemiesFolder:GetChildren()) do
            if not castleInfEnabled then break end

            local hp = mob:GetAttribute("HP")
            if hp and hp > 0 and mob.Position then
                local char = Player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                
                if hrp then
                    hrp.CFrame = mob.CFrame * CFrame.new(0, 0, 3)

                    SafeFire({
                        PetPos = {},
                        AttackType = "All",
                        Event = "Attack",
                        Enemy = mob.Name
                    })

                    while castleInfEnabled and mob.Parent do
                        local currentHP = mob:GetAttribute("HP")
                        if not currentHP or currentHP <= 0 then
                            break
                        end
                        task.wait(0.2)
                    end

                    mobsKilled = true
                end
            end
        end
    end

    return mobsKilled
end

-- =====================================================
-- CASTLE LOOPS
-- =====================================================
local function castleInfLoop()
    task.spawn(function()
        while castleInfEnabled do
            local hasMobs = farmCastleMobs()
            if not hasMobs then
                if teleportToFirePortal() then
                    task.wait(1)
                    activateFirePortal()
                end
            end
            task.wait(0.4)
        end
    end)
end

local function autoCastleLoop()
    task.spawn(function()
        while autoCastleEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            else
                if currentFloor >= resetFloor then
                    buyCastleTicket()
                    task.wait(1)
                    createCastle()
                    task.wait(1)
                    joinCastle(entryFloor)
                    task.wait(5)
                else
                    farmCastleMobs()
                end
            end
            task.wait(0.5)
        end
    end)
end

local function castleCreateOnlyLoop()
    task.spawn(function()
        while castleCreateOnlyEnabled do
            local currentFloor = getCurrentCastleFloor()
            if not currentFloor then
                buyCastleTicket()
                task.wait(1)
                createCastle()
                task.wait(1)
                joinCastle(entryFloor)
                task.wait(5)
            end
            task.wait(1)
        end
    end)
end

-- =====================================================
-- CASTLE UI
-- =====================================================
Tabs.Castle:AddInput("EntryFloor", {
    Title = "Andar de Entrada",
    Default = tostring(Settings.EntryFloor),
    Numeric = true,
    Finished = true,
    Callback = function(v)
        local n = tonumber(v)
        if n then
            entryFloor = n
            Settings.EntryFloor = n
            SaveSettings()
        end
    end
})

Tabs.Castle:AddInput("ResetFloor", {
    Title = "Andar de Reset",
    Default = tostring(Settings.ResetFloor),
    Numeric = true,
    Finished = true,
    Callback = function(v)
        local n = tonumber(v)
        if n then
            resetFloor = n
            Settings.ResetFloor = n
            SaveSettings()
        end
    end
})

Tabs.Castle:AddToggle("CastleINF", {
    Title = "Castle INF (Farm + Portal)",
    Default = Settings.CastleInf,
    Callback = function(v)
        castleInfEnabled = v
        Settings.CastleInf = v
        SaveSettings()
        if v then castleInfLoop() end
    end
})

Tabs.Castle:AddToggle("AutoCastle", {
    Title = "Auto Castle (Create + Reset)",
    Default = Settings.AutoCastle,
    Callback = function(v)
        autoCastleEnabled = v
        Settings.AutoCastle = v
        SaveSettings()
        if v then autoCastleLoop() end
    end
})

Tabs.Castle:AddToggle("CastleCreateOnly", {
    Title = "Auto Castle (Criar Apenas)",
    Default = Settings.CastleCreateOnly,
    Callback = function(v)
        castleCreateOnlyEnabled = v
        Settings.CastleCreateOnly = v
        SaveSettings()
        if v then castleCreateOnlyLoop() end
    end
})

Tabs.Castle:AddDropdown("CastleSpeed", {
    Title = "Speed do Castelo",
    Values = {"1", "2", "4"},
    Default = Settings.CastleSpeed,
    Callback = function(v)
        selectedCastleSpeed = v
        Settings.CastleSpeed = v
        SaveSettings()
        
        if castleSpeedEnabled then
            SafeFire({
                Event = "CastleAction",
                Action = "SpeedUp",
                Speed = tonumber(v)
            })
        end
    end
})

Tabs.Castle:AddToggle("EnableCastleSpeed", {
    Title = "Ativar Speed do Castelo",
    Default = Settings.CastleSpeedEnabled,
    Callback = function(v)
        castleSpeedEnabled = v
        Settings.CastleSpeedEnabled = v
        SaveSettings()
        
        if v then
            SafeFire({
                Event = "CastleAction",
                Action = "SpeedUp",
                Speed = tonumber(selectedCastleSpeed)
            })
        end
    end
})

-- =====================================================
-- ISLANDS
-- =====================================================
local SelectedIslandName = nil
local IslandMap = {}
local function GetWorld()
local extra = workspace:FindFirstChild("__Extra")
if not extra then return nil end
return extra:FindFirstChild("__Spawns")
end
local function GetIslandDisplayName(island)
if island:GetAttribute("DisplayName") then return island:GetAttribute("DisplayName") end
if island:GetAttribute("Name") then return island:GetAttribute("Name") end
for _, child in ipairs(island:GetChildren()) do
if child:IsA("StringValue") then
return child.Value
end
end
return island.Name
end
local function ScanIslands()
table.clear(IslandMap)
local World = GetWorld()
if not World then return {} end
local list = {}
for _, island in ipairs(World:GetChildren()) do
local displayName = GetIslandDisplayName(island)
IslandMap[displayName] = island
table.insert(list, displayName)
end
table.sort(list)
return list
end
local function TeleportToIsland(islandModel)
local char = Players.LocalPlayer.Character
if not char or not char:FindFirstChild("HumanoidRootPart") then return end
local hrp = char.HumanoidRootPart
if islandModel.GetPivot then
hrp.CFrame = islandModel:GetPivot() * CFrame.new(0, 10, 0)
elseif islandModel.PrimaryPart then
hrp.CFrame = islandModel.PrimaryPart.CFrame * CFrame.new(0, 10, 0)
elseif islandModel:IsA("BasePart") then
hrp.CFrame = islandModel.CFrame * CFrame.new(0, 10, 0)
end
end
local IslandDropdown = Tabs.Islands:AddDropdown("IslandDropdown", {
Title = "Ilhas Detectadas",
Values = ScanIslands(),
Multi = false,
Callback = function(value)
SelectedIslandName = value
end
})
Tabs.Islands:AddButton({
Title = "Teleportar Ilha Selecionada",
Description = "Vai para a ilha escolhida no dropdown",
Callback = function()
if not SelectedIslandName then
Fluent:Notify({
Title = "Erro",
Content = "Nenhuma ilha selecionada",
Duration = 3
})
return
end
local islandModel = IslandMap[SelectedIslandName]
if islandModel then
TeleportToIsland(islandModel)
Fluent:Notify({
Title = "Teleport",
Content = "Voc√™ foi para " .. SelectedIslandName,
Duration = 3
})
end
end
})
-- Atualiza√ß√£o autom√°tica do dropdown
task.spawn(function()
while task.wait(6) do
if IslandDropdown then
IslandDropdown:SetValues(ScanIslands())
end
end
end)

-- =====================================================
-- SETTINGS
-- =====================================================
SaveManager:BuildConfigSection(Tabs.Settings)

Tabs.Settings:AddParagraph({
    Title = "üíæ Sistema de Salvamento",
    Content = "Suas configura√ß√µes s√£o salvas automaticamente!"
})

Tabs.Settings:AddButton({
    Title = "üíæ Salvar Configura√ß√µes",
    Description = "Salva manualmente todas as configura√ß√µes",
    Callback = function()
        SaveSettings()
        Fluent:Notify({
            Title = "Salvamento",
            Content = "Configura√ß√µes salvas com sucesso!",
            Duration = 3
        })
    end
})

Tabs.Settings:AddButton({
    Title = "üîÑ Recarregar Configura√ß√µes",
    Description = "Recarrega as configura√ß√µes do arquivo",
    Callback = function()
        LoadSettings()
        Fluent:Notify({
            Title = "Salvamento",
            Content = "Configura√ß√µes recarregadas!",
            Duration = 3
        })
    end
})

Tabs.Settings:AddButton({
    Title = "üóëÔ∏è Resetar Todas Configura√ß√µes",
    Description = "Volta para os valores padr√£o",
    Callback = function()
        if delfile and isfile(SETTINGS_FILE) then
            delfile(SETTINGS_FILE)
        end
        
        for key in pairs(Settings) do
            if key:find("RuneSlot") then
                Settings[key] = "Nenhuma"
            elseif type(Settings[key]) == "boolean" then
                Settings[key] = false
            elseif key == "MoveMode" then
                Settings[key] = "Tween"
            elseif key == "CastleSpeed" then
                Settings[key] = "1"
            elseif key == "EntryFloor" then
                Settings[key] = 1
            elseif key == "ResetFloor" then
                Settings[key] = 100
            end
        end
        
        SaveSettings()
        
        Fluent:Notify({
            Title = "Resetado",
            Content = "Configura√ß√µes resetadas com sucesso!",
            Duration = 3
        })
    end
})

Tabs.Settings:AddButton({
    Title = "üîÑ Reconectar Servidor",
    Description = "Reconecta ao servidor atual",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, Player)
    end
})

-- =====================================================
-- NOTIFICA√á√ÉO FINAL
-- =====================================================
Fluent:Notify({
    Title = "Allan Hub V2",
    Content = "Script carregado com sucesso! üéâ",
    Duration = 6
})

print("‚úÖ ALLAN HUB V2 CARREGADO")
print("üíæ Sistema de salvamento: ATIVO")
print("üîÆ Runas detectadas: " .. #AvailableRunes)
print("üîë Detec√ß√£o autom√°tica de ID da dungeon: ATIVO")
print("‚öôÔ∏è Todas as configura√ß√µes ser√£o salvas automaticamente!")
